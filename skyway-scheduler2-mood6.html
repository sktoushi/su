<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta http-equiv="Cache-Control" content="no-store" />
<title>Mood Tracker (IndexedDB + SPC X-MR)</title>
<style>
  :root{
    --bg:#0b0c10; --fg:#cfd8dc; --muted:#90a4ae; --accent:#7cb342;
    --btn:#263238; --btn-hover:#37474f; --btn-active:#455a64; --danger:#e53935;
    --border:#1b2328; --paper:#11161a; --chip:#0f1519;
    --good:#64dd17; --warn:#ffb300; --bad:#ff5252;
    --good-bg:rgba(100,221,23,.12); --good-bd:#1b5e20; --good-fg:#b9f6ca;
    --bad-bg:rgba(229,57,53,.12);  --bad-bd:#7f1d1d;  --bad-fg:#ffb4af;
    --forced-bg:rgba(255,179,0,.12); --forced-bd:#5f370e; --forced-fg:#ffd8a8;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    min-height:100svh}
  main{margin:2rem auto;width:min(100%,1180px)}
  .paper{background:var(--paper);border-radius:18px;box-shadow:0 20px 60px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.05) inset;padding:1.25rem}
  h1{margin:.25rem 0 .35rem 0;font-weight:750;font-size:1.35rem}
  .lead{margin:.25rem 0 1rem 0;color:var(--muted)}
  .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .btn{border:1px solid #111;background:var(--btn);color:var(--fg);padding:.6rem 1rem;border-radius:.5rem;font-size:1rem;cursor:pointer;
    transition:transform .05s ease,background .15s ease,box-shadow .15s ease;box-shadow:0 2px 0 rgba(0,0,0,.3);user-select:none;text-decoration:none}
  .btn:hover{background:var(--btn-hover)}
  .btn:active{transform:translateY(1px);background:var(--btn-active)}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-accent{background:var(--accent);color:#0b0c10;border-color:#5a8e2f}
  .btn-danger{background:var(--danger);color:#fff;border-color:#b71c1c}
  .btn-outline{background:transparent;border-color:var(--border);color:var(--fg)}
  .btn-small{padding:.35rem .6rem;font-size:.88rem;border-radius:.45rem}
  .small{color:var(--muted);font-size:.92rem}
  .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
  .spacer{flex:1}
  .pill{font-size:.85rem;padding:.2rem .5rem;border-radius:.9rem;background:#1c313a;color:#b2dfdb;border:1px solid rgba(255,255,255,.06);letter-spacing:.2px}
  .chips{display:flex;gap:.5rem;flex-wrap:wrap;margin:.5rem 0}
  .chip{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:.45rem .75rem;cursor:pointer}
  .chip:hover{background:#132028}
  .chip.active{outline:2px solid #7cb342}
  .list{margin-top:1rem;border-top:1px dashed rgba(255,255,255,.08)}
  .entry{
    display:grid;
    grid-template-columns:160px 1fr auto;
    gap:.75rem;
    padding:.6rem 0;border-bottom:1px dashed rgba(255,255,255,.08)
  }
  .score{font-weight:700}
  .tagline{color:var(--muted)}
  .badge{padding:.1rem .4rem;border-radius:.4rem;border:1px solid var(--border);font-size:.8rem}
  .badge.bad{border-color:#7f1d1d;color:#ffb4af;background:rgba(229,57,53,.12)}
  .badge.warn{border-color:#5f370e;color:#ffd8a8;background:rgba(255,179,0,.12)}
  .badge.good{border-color:#1b5e20;color:#b9f6ca;background:rgba(100,221,23,.12)}

  .dchips{display:flex;gap:.35rem;flex-wrap:wrap;margin-top:.25rem}
  .dchip{font-size:.8rem;padding:.2rem .5rem;border-radius:999px;border:1px solid transparent}
  .d-good{background:var(--good-bg);border-color:var(--good-bd);color:var(--good-fg)}
  .d-bad{background:var(--bad-bg);border-color:var(--bad-bd);color:var(--bad-fg)}
  .d-forced{background:var(--forced-bg);border-color:var(--forced-bd);color:var(--forced-fg)}
  .dtitle{font-size:.8rem;opacity:.85;margin-right:.25rem}

  /* Modal ‚Äî bulletproof visibility */
  #modalWrap{
    position:fixed; inset:0; background:rgba(0,0,0,.6);
    place-items:center; padding:1rem;
    z-index:10000; pointer-events:auto;
  }
  #modalWrap[aria-hidden="true"]{ display:none !important; }
  #modalWrap[aria-hidden="false"]{ display:grid !important; }
  .modal{width:min(100%,760px);background:var(--paper);border-radius:14px;border:1px solid var(--border);box-shadow:0 30px 70px rgba(0,0,0,.6);padding:1rem}
  .modal header{display:flex;align-items:center;justify-content:space-between}
  .field{margin:.75rem 0}
  .field label{display:block;margin-bottom:.35rem;font-weight:600}
  .field input[type="range"]{width:100%}
  .field input[type="text"], .field input[type="number"], .field textarea{
    width:100%;background:#0c1114;border:1px solid var(--border);border-radius:.5rem;color:var(--fg);
    padding:.65rem .75rem;font:inherit
  }

  .grid3{display:grid;grid-template-columns:1fr;gap:.75rem}
  @media (min-width:720px){ .grid3{grid-template-columns:repeat(3,1fr)} }
  .stack{display:grid;grid-template-columns:1fr auto;gap:.35rem;align-items:center}
  .label-good{color:var(--good-fg)}
  .label-bad{color:var(--bad-fg)}
  .label-forced{color:var(--forced-fg)}
  .legend{display:flex;gap:.5rem;align-items:center;font-size:.9rem}
  .legend .box{width:10px;height:10px;border-radius:2px;display:inline-block}
  .box-good{background:var(--good-bg);border:1px solid var(--good-bd)}
  .box-bad{background:var(--bad-bg);border:1px solid var(--bad-bd)}
  .box-forced{background:var(--forced-bg);border:1px solid var(--forced-bd)}

  .grid{display:grid;grid-template-columns:1fr;gap:1rem}
  @media (min-width:1200px){ .grid{grid-template-columns:1.1fr .9fr} }
  .grid-wide{display:grid;grid-template-columns:1fr;gap:1rem}
  @media (min-width:1200px){ .grid-wide{grid-template-columns:1fr 1fr} }
  .card{background:#0c1114;border:1px solid var(--border);border-radius:12px;padding:1rem}
  .kv{display:grid;grid-template-columns:1fr 1fr;gap:.4rem .75rem}
  .kv div{padding:.15rem 0;border-bottom:1px dashed rgba(255,255,255,.06)}
  .kv b{font-weight:700}
  canvas{width:100%;height:260px;background:white;border-radius:8px;display:block}

  .btn:focus-visible, a:focus-visible, input:focus-visible, textarea:focus-visible, .chip:focus-visible{
    outline:2px solid #9ccc65;outline-offset:2px
  }
</style>
</head>
<body>
  <main>
    <section class="paper" aria-labelledby="title">
      <header class="row" style="justify-content:space-between">
        <div>
          <h1 id="title">Mood Tracker (IndexedDB + SPC)</h1>
          <p class="lead small">Log your mood (1‚Äì10) with an optional cause & decisions. We compute X-MR control charts and flag signals.</p>
        </div>
        <div class="toolbar">
          <button id="addBtn" class="btn btn-accent btn-small" type="button" onclick="openModal()">‚ûï Add entry</button>
          <button id="exportBtn" class="btn btn-outline btn-small" type="button" title="Export JSON">‚¨áÔ∏è Export</button>
          <button id="importBtn" class="btn btn-outline btn-small" type="button" title="Import JSON">‚¨ÜÔ∏è Import</button>
          <input id="importFile" type="file" accept="application/json" style="display:none" />
          <button id="clearBtn" class="btn btn-outline btn-small" type="button" title="Clear all data">üóëÔ∏è Clear all</button>
        </div>
      </header>

      <div class="row small" style="margin:.35rem 0 1rem 0">
        <span class="pill" id="status" aria-live="polite">Ready</span>
        <span class="pill" id="countPill">Entries: 0</span>
      </div>

      <div class="grid">
        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">Your entries</h3>
          <div class="chips" id="tagChips" aria-label="Previous tags"></div>
          <div id="entries" class="list" aria-live="polite"></div>
        </div>

        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">SPC (Individuals & Moving Range) ‚Äî Mood</h3>
          <div class="kv small" id="spcMeta"></div>
          <div style="margin:.6rem 0">
            <canvas id="xChart" aria-label="Individuals chart (Mood)" tabindex="0"></canvas>
          </div>
          <div style="margin:.6rem 0">
            <canvas id="mrChart" aria-label="Moving range chart (Mood)" tabindex="0"></canvas>
          </div>
          <details open>
            <summary><b>Signals & notes</b></summary>
            <ul id="signals" class="small" style="line-height:1.45"></ul>
          </details>
          <details>
            <summary><b>Cause clusters (signals-only)</b></summary>
            <ul id="clustersMood" class="small" style="line-height:1.45"></ul>
          </details>
          <div class="row" style="margin-top:.6rem">
            <div class="spacer"></div>
            <button id="copyExplain" class="btn btn-accent btn-small" type="button">üìã Copy all SPC + open ChatGPT</button>
          </div>
        </div>
      </div>

      <div class="grid-wide" style="margin-top:1rem">
        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">SPC ‚Äî Decision Score</h3>
          <div class="small legend" style="margin-bottom:.35rem">
            <span class="box box-good"></span> Good decisions (+w)
            <span class="box box-bad" style="margin-left:.5rem"></span> Bad decisions (‚àíw)
            <span class="box box-forced" style="margin-left:.5rem"></span> Forced (neutral score)
          </div>
          <div class="kv small" id="spcMetaDecision"></div>
          <div style="margin:.6rem 0">
            <canvas id="xChartDec" aria-label="Individuals chart (Decision Score)" tabindex="0"></canvas>
          </div>
          <div style="margin:.6rem 0">
            <canvas id="mrChartDec" aria-label="Moving range chart (Decision Score)" tabindex="0"></canvas>
          </div>
          <details open>
            <summary><b>Signals & notes</b></summary>
            <ul id="signalsDec" class="small" style="line-height:1.45"></ul>
          </details>
          <details>
            <summary><b>Cause clusters (signals-only)</b></summary>
            <ul id="clustersDecision" class="small" style="line-height:1.45"></ul>
          </details>
        </div>

        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">SPC ‚Äî Composite (zMood + zDecision)</h3>
          <div class="kv small" id="spcMetaComposite"></div>
          <div style="margin:.6rem 0">
            <canvas id="xChartComp" aria-label="Individuals chart (Composite)" tabindex="0"></canvas>
          </div>
          <div style="margin:.6rem 0">
            <canvas id="mrChartComp" aria-label="Moving range chart (Composite)" tabindex="0"></canvas>
          </div>
          <details open>
            <summary><b>Signals & notes</b></summary>
            <ul id="signalsComp" class="small" style="line-height:1.45"></ul>
          </details>
          <details>
            <summary><b>Cause clusters (signals-only)</b></summary>
            <ul id="clustersComposite" class="small" style="line-height:1.45"></ul>
          </details>
        </div>
      </div>
    </section>
  </main>

  <!-- Modal -->
  <div id="modalWrap" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="mTitle" aria-hidden="true" tabindex="-1">
    <div class="modal">
      <header>
        <h2 id="mTitle" style="margin:.2rem 0">Add mood entry</h2>
        <button id="closeModal" class="btn btn-outline btn-small" type="button" aria-label="Close">‚úï</button>
      </header>

      <div class="field">
        <label for="moodRange">Mood score: <b><span id="moodVal">5</span>/10</b></label>
        <input id="moodRange" type="range" min="1" max="10" step="1" value="5" />
      </div>

      <div class="field">
        <label for="tagInput">Optional text (concern / cause)</label>
        <input id="tagInput" type="text" placeholder="e.g., poor sleep, work stress, gym, friends, caffeine, rain" />
        <div id="recentChips" class="chips" aria-label="Quick pick from previous"></div>
      </div>

      <!-- Decisions -->
      <div class="field">
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <label>Decisions (optional)</label>
          <div class="legend">
            <span class="box box-good"></span> Good
            <span class="box box-bad"></span> Bad
            <span class="box box-forced"></span> Forced
          </div>
        </div>
        <div class="grid3">
          <div>
            <div class="small label-good"><b>Good decisions</b> (1‚Äì3)</div>
            <div class="stack" style="margin-top:.35rem"><input id="gd1" type="text" placeholder="Good decision 1"><input id="gw1" type="number" min="0" max="10" step="1" value="1" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="gd2" type="text" placeholder="Good decision 2"><input id="gw2" type="number" min="0" max="10" step="1" value="2" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="gd3" type="text" placeholder="Good decision 3"><input id="gw3" type="number" min="0" max="10" step="1" value="3" placeholder="w"></div>
          </div>
          <div>
            <div class="small label-bad"><b>Bad decisions</b> (1‚Äì3)</div>
            <div class="stack" style="margin-top:.35rem"><input id="bd1" type="text" placeholder="Bad decision 1"><input id="bw1" type="number" min="0" max="10" step="1" value="1" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="bd2" type="text" placeholder="Bad decision 2"><input id="bw2" type="number" min="0" max="10" step="1" value="2" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="bd3" type="text" placeholder="Bad decision 3"><input id="bw3" type="number" min="0" max="10" step="1" value="3" placeholder="w"></div>
          </div>
          <div>
            <div class="small label-forced"><b>Forced decisions</b> (1‚Äì3)</div>
            <div class="stack" style="margin-top:.35rem"><input id="fd1" type="text" placeholder="Forced decision 1"><input id="fw1" type="number" min="0" max="10" step="1" value="1" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="fd2" type="text" placeholder="Forced decision 2"><input id="fw2" type="number" min="0" max="10" step="1" value="2" placeholder="w"></div>
            <div class="stack" style="margin-top:.35rem"><input id="fd3" type="text" placeholder="Forced decision 3"><input id="fw3" type="number" min="0" max="10" step="1" value="3" placeholder="w"></div>
          </div>
        </div>
      </div>

      <div class="row" style="justify-content:flex-end;margin-top:.5rem">
        <button id="saveEntry" class="btn btn-accent" type="button">üíæ Save</button>
      </div>
    </div>
  </div>

<script>
/* ===== Utilities & Error Reporter ===== */
const $ = sel => document.querySelector(sel);
const statusEl = $("#status"); const entriesEl = $("#entries"); const tagChipsEl = $("#tagChips");
const countPill = $("#countPill");
const modalWrap = document.getElementById("modalWrap");
const addBtn = document.getElementById("addBtn");
const closeModalBtn = document.getElementById("closeModal");
const saveBtn = document.getElementById("saveEntry");
const clearBtn = document.getElementById("clearBtn");
const exportBtn = document.getElementById("exportBtn");
const importBtn = document.getElementById("importBtn");
const importFile = document.getElementById("importFile");
const moodRange = document.getElementById("moodRange"); const moodVal = document.getElementById("moodVal");
const tagInput = document.getElementById("tagInput"); const recentChips = document.getElementById("recentChips");
const xChart = document.getElementById("xChart"); const mrChart = document.getElementById("mrChart");
const xChartDec = document.getElementById("xChartDec"); const mrChartDec = document.getElementById("mrChartDec");
const xChartComp = document.getElementById("xChartComp"); const mrChartComp = document.getElementById("mrChartComp");
const copyExplainBtn = document.getElementById("copyExplain");

function setStatus(msg, kind="info"){
  statusEl.textContent = msg;
  if(kind==="ok"){ statusEl.style.background="#1c313a"; statusEl.style.color="#b2dfdb"; }
  else if(kind==="err"){ statusEl.style.background="rgba(229,57,53,.15)"; statusEl.style.color="#ffb4af"; }
  else { statusEl.style.background="#1c313a"; statusEl.style.color="#b2dfdb"; }
}
window.addEventListener("error", (e)=> setStatus(`JS error: ${e.message}`, "err"));
window.addEventListener("unhandledrejection", (e)=> setStatus(`Promise error: ${e.reason}`, "err"));

/* ===== Modal: bulletproof toggling ===== */
function resetDecisionWeightsToDefaults(){
  const def = [1,2,3];
  ["g","b","f"].forEach(prefix=>{
    def.forEach((v,i)=>{
      const wEl = document.getElementById(prefix+"w"+(i+1));
      if(wEl){ wEl.value = String(v); }
    });
  });
}
function openModal(){
  modalWrap.setAttribute("aria-hidden","false");
  tagInput.value = "";
  moodRange.value = "5"; moodVal.textContent = "5";
  ["gd1","gd2","gd3","bd1","bd2","bd3","fd1","fd2","fd3"].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
  resetDecisionWeightsToDefaults();
  buildRecentChips();
  setTimeout(()=>{ modalWrap.focus(); tagInput.focus(); }, 10);
}
function closeModal(){ modalWrap.setAttribute("aria-hidden","true"); }
window.openModal = openModal;
addBtn?.addEventListener("click", openModal);
closeModalBtn?.addEventListener("click", closeModal);
modalWrap?.addEventListener("click", e=>{ if(e.target===modalWrap) closeModal(); });
document.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && modalWrap.getAttribute("aria-hidden")==="false") closeModal(); });
moodRange?.addEventListener("input", ()=>{ moodVal.textContent = moodRange.value; });

/* ===== DB (with fallback) ===== */
const DB_NAME = "moodDB_v1";
const DB_VERSION = 2;
const STORE = "moods";
let dbPromise;
const hasIDB = !!window.indexedDB;

function openDB(){
  if(!hasIDB){
    setStatus("IndexedDB unavailable; using localStorage fallback.", "err");
    return Promise.resolve(null);
  }
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)){
        const store = db.createObjectStore(STORE, { keyPath:"id" });
        store.createIndex("by_time","time",{unique:false});
        store.createIndex("by_tag","tag",{unique:false});
      } else {
        try{
          const store = req.transaction.objectStore(STORE);
          if(!store.indexNames.contains("by_time")) store.createIndex("by_time","time",{unique:false});
          if(!store.indexNames.contains("by_tag")) store.createIndex("by_tag","tag",{unique:false});
        }catch(_){}
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
    req.onblocked = () => setStatus("DB upgrade blocked (close other tabs).", "err");
  });
  return dbPromise;
}
async function addEntry(score, tagText, decisions){
  const db = await openDB();
  const item = { id: crypto?.randomUUID?.() ?? String(Date.now()), time: Date.now(), score, tag: (tagText||"").trim(), decisions };
  if(!db){
    const key = "mood_local_fallback";
    const arr = JSON.parse(localStorage.getItem(key)||"[]");
    arr.push(item);
    localStorage.setItem(key, JSON.stringify(arr));
    return item;
  }
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).add(item);
    tx.oncomplete = () => resolve(item);
    tx.onerror = () => reject(tx.error);
  });
}
async function getAllEntries(){
  const db = await openDB();
  if(!db){
    const arr = JSON.parse(localStorage.getItem("mood_local_fallback")||"[]");
    return arr.sort((a,b)=>a.time-b.time);
  }
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result.sort((a,b)=>a.time-b.time));
    req.onerror = () => reject(req.error);
  });
}
async function deleteEntry(id){
  const db = await openDB();
  if(!db){
    const key = "mood_local_fallback";
    const arr = JSON.parse(localStorage.getItem(key)||"[]");
    const next = arr.filter(e=>e.id!==id);
    localStorage.setItem(key, JSON.stringify(next));
    return;
  }
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).delete(id);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
async function clearAll(){
  const db = await openDB();
  if(!db){ localStorage.removeItem("mood_local_fallback"); return; }
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

/* ===== Import/Export helpers ===== */
function tsFilename(){
  const d = new Date();
  const pad = x => String(x).padStart(2,"0");
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}
async function exportJSON(){
  try{
    const all = await getAllEntries();
    const payload = { schema: "mood-tracker.v1", exportedAt: new Date().toISOString(), count: all.length, data: all };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = `mood-tracker-export-${tsFilename()}.json`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    setStatus(`Exported ${all.length} entr${all.length===1?"y":"ies"}.`, "ok");
  }catch(e){
    console.error(e); setStatus(`Export failed: ${e?.message||e}`, "err");
  }
}
function sanitizeDecisionArray(arr){
  if(!Array.isArray(arr)) return [];
  return arr.map(x=>{
    const text = typeof x?.text === "string" ? x.text.trim() : "";
    const weight = Number.isFinite(+x?.weight) ? Math.max(0, +x.weight) : 0;
    return { text, weight };
  }).filter(x=>x.text || x.weight>0);
}
function sanitizeItem(raw){
  const id = typeof raw?.id === "string" && raw.id ? raw.id : (crypto?.randomUUID?.() ?? `imp-${Date.now()}-${Math.random().toString(16).slice(2)}`);
  const time = Number.isFinite(+raw?.time) ? +raw.time : Date.now();
  const score = Math.min(10, Math.max(1, Number.isFinite(+raw?.score) ? +raw.score : 5));
  const tag = typeof raw?.tag === "string" ? raw.tag.trim() : "";
  const decisions = raw?.decisions && typeof raw.decisions === "object" ? {
    good: sanitizeDecisionArray(raw.decisions.good),
    bad: sanitizeDecisionArray(raw.decisions.bad),
    forced: sanitizeDecisionArray(raw.decisions.forced),
  } : { good:[], bad:[], forced:[] };
  return { id, time, score, tag, decisions };
}
async function importEntries(items){
  const arr = Array.isArray(items) ? items : (Array.isArray(items?.data) ? items.data : null);
  if(!arr) throw new Error("Invalid JSON: expected an array or object with `data`.");
  const sanitized = arr.map(sanitizeItem);

  const db = await openDB();
  if(!db){
    const key = "mood_local_fallback";
    const existing = JSON.parse(localStorage.getItem(key)||"[]");
    const existingIds = new Set(existing.map(e=>e.id));
    const merged = [...existing];
    sanitized.forEach(it=>{
      let id = it.id;
      if(existingIds.has(id)){ id = crypto?.randomUUID?.() ?? `${id}-dup-${Math.random().toString(16).slice(2)}`; }
      merged.push({...it, id});
    });
    localStorage.setItem(key, JSON.stringify(merged));
    return sanitized.length;
  }else{
    const existing = await new Promise((resolve,reject)=>{
      const tx = db.transaction(STORE,"readonly");
      const req = tx.objectStore(STORE).getAllKeys();
      req.onsuccess = () => resolve(new Set(req.result || []));
      req.onerror = () => reject(req.error);
    });
    await new Promise((resolve,reject)=>{
      const tx = db.transaction(STORE,"readwrite");
      const store = tx.objectStore(STORE);
      sanitized.forEach(it=>{
        const rec = {...it};
        if(existing.has(rec.id)){ rec.id = crypto?.randomUUID?.() ?? `${rec.id}-dup-${Math.random().toString(16).slice(2)}`; }
        store.add(rec);
      });
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
    return sanitized.length;
  }
}

/* ===== Chips ===== */
function makeChip(text, onClick){
  const chip = document.createElement("button");
  chip.type = "button";
  chip.className = "chip btn-small";
  chip.textContent = text;
  chip.addEventListener("click", (e) => onClick(e));
  return chip;
}
async function buildRecentChips(){
  const all = await getAllEntries();
  const seen = new Set(); const list = [];
  [...all].reverse().forEach(e=>{
    const t = (e.tag||"").trim();
    if(t && !seen.has(t)){ seen.add(t); list.push(t); }
  });
  recentChips.innerHTML="";
  list.slice(0,10).forEach(t=>{ recentChips.appendChild(makeChip(t, ()=>{ tagInput.value = t; })); });
  if(list.length===0){ recentChips.innerHTML = `<span class="small" style="opacity:.8">No previous causes yet. Add one!</span>`; }
}
function buildTagBar(all){
  const seen = new Set(); const list = [];
  [...all].reverse().forEach(e => {
    const t = (e.tag||"").trim();
    if(t && !seen.has(t)){ seen.add(t); list.push(t); }
  });
  tagChipsEl.innerHTML="";
  list.slice(0,12).forEach(t=>{
    tagChipsEl.appendChild(makeChip(t, (e)=>{
      const active = e.currentTarget.classList.toggle("active");
      document.querySelectorAll(".chip").forEach(c=>{
        if(c!==e.currentTarget && c.parentElement===tagChipsEl) c.classList.remove("active");
      });
      renderEntries(active ? all.filter(e2=> (e2.tag||"").trim()===t) : all);
    }));
  });
  tagChipsEl.prepend(makeChip("All", ()=>{ 
    document.querySelectorAll(".chip").forEach(c=>c.classList.remove("active"));
    renderEntries(all);
  }));
}

/* ===== Decision helpers ===== */
function gatherDecisionsFromModal(){
  function collect(prefix) {
    const arr = [];
    for (let i=1;i<=3;i++){
      const tEl = document.getElementById(prefix+"d"+i);
      const wEl = document.getElementById(prefix+"w"+i);
      const t = (tEl?.value||"").trim();
      const wRaw = (wEl?.value ?? "").toString().trim();
      const wNum = wRaw==="" ? 0 : Number(wRaw);
      if (t) arr.push({ text: t, weight: (Number.isFinite(wNum) ? Math.max(0,wNum) : 0) });
    }
    return arr;
  }
  return { good: collect("g"), bad: collect("b"), forced: collect("f") };
}
const decisionScore = dec => (dec?.good||[]).reduce((a,b)=>a+(+b.weight||0),0) - (dec?.bad||[]).reduce((a,b)=>a+(+b.weight||0),0);
const forcedLoad = dec => (dec?.forced||[]).reduce((a,b)=>a+(+b.weight||0),0);

/* ===== Render entries ===== */
function fmtDate(ts){
  const d = new Date(ts);
  return d.toLocaleString(undefined,{year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'});
}
function renderDecisionChips(e){
  const D = e.decisions || {good:[],bad:[],forced:[]};
  const mk = (arr, cls) => (arr||[]).filter(x=>x && ((x.text||"").trim() || (+x.weight>0)))
    .map(x=>`<span class="dchip ${cls}" title="w=${+x.weight||0}">${(x.text||"(no label)")} <span style="opacity:.8">(${+x.weight||0})</span></span>`).join("");
  const good = mk(D.good,"d-good"), bad = mk(D.bad,"d-bad"), forced = mk(D.forced,"d-forced");
  if(!(good||bad||forced)) return "";
  return `<div class="dchips">
    ${good? `<span class="dtitle">Good:</span> ${good}`:""}
    ${bad? `<span class="dtitle" style="margin-left:.5rem">Bad:</span> ${bad}`:""}
    ${forced? `<span class="dtitle" style="margin-left:.5rem">Forced:</span> ${forced}`:""}
  </div>`;
}
function renderEntries(all){
  countPill.textContent = `Entries: ${all.length}`;
  entriesEl.innerHTML = "";
  if(all.length===0){
    entriesEl.innerHTML = `<div class="small" style="padding:1rem 0;opacity:.8">No entries yet. Click <b>‚ûï Add entry</b> to start.</div>`;
    renderAllSPC([]); return;
  }
  all.forEach(e=>{
    const div = document.createElement("div");
    div.className = "entry";
    div.dataset.id = e.id;
    const quality = e.score>=8 ? "good" : e.score<=3 ? "bad" : "warn";
    div.innerHTML = `
      <div>
        <div class="score">Mood: ${e.score}/10</div>
        <div class="tagline small">${fmtDate(e.time)}</div>
      </div>
      <div>
        ${(e.tag? `<span class="badge ${quality}">${e.tag}</span>`:"")}
        ${renderDecisionChips(e)}
      </div>
      <div class="row" style="justify-content:flex-end;align-items:start">
        <button class="btn btn-danger btn-small" type="button" data-del="${e.id}" title="Delete entry">üóëÔ∏è</button>
      </div>`;
    entriesEl.appendChild(div);
  });
  renderAllSPC(all);
}

/* per-entry delete (event delegation) */
entriesEl.addEventListener("click", async (ev)=>{
  const btn = ev.target.closest('button[data-del]');
  if(!btn) return;
  const id = btn.getAttribute('data-del');
  if(!id) return;
  if(!confirm("Delete this entry?")) return;
  try{
    await deleteEntry(id);
    setStatus("Entry deleted.", "ok");
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(e){
    console.error(e); setStatus(`Delete failed: ${e?.message||e}`, "err");
  }
});

/* ===== SPC core/helpers ===== */
function spcCompute(values){
  const n = values.length;
  if(n===0) return { n:0, mrs:[], signals:[] };
  const mean = values.reduce((a,b)=>a+b,0)/n;
  const mrs = [];
  for(let i=1;i<n;i++) mrs.push(Math.abs(values[i]-values[i-1]));
  const mrbar = mrs.length? mrs.reduce((a,b)=>a+b,0)/mrs.length : 0;
  const d2 = 1.128;
  const sigma = mrbar/d2;
  const ucl = mean + 3*sigma;
  const lcl = mean - 3*sigma;
  const mrUCL = 3.267*mrbar;
  const mrLCL = 0;

  const signals = [];
  values.forEach((x,i)=>{ if(x>ucl || x<lcl) signals.push({i, rule:"Point beyond 3œÉ limit", value:x}); });
  (function(){
    if (n===0) return;
    let runStart=0, prevSide = Math.sign(values[0]-mean);
    for(let i=1;i<n;i++){
      const side = Math.sign(values[i]-mean);
      if(side===0){ runStart=i; prevSide=0; continue; }
      if(side===prevSide && side!==0) {
        if(i-runStart+1>=8) signals.push({i, rule:"‚â•8 in a row on one side of mean", value:values[i]});
      } else { runStart=i; }
      prevSide = side;
    }
  })();
  (function(){
    let up=1, dn=1;
    for(let i=1;i<n;i++){
      if(values[i]>values[i-1]){ up++; dn=1; }
      else if(values[i]<values[i-1]){ dn++; up=1; }
      else { up=1; dn=1; }
      if(up>=6) signals.push({i, rule:"‚â•6 increasing", value:values[i]});
      if(dn>=6) signals.push({i, rule:"‚â•6 decreasing", value:values[i]});
    }
  })();
  mrs.forEach((r,i)=>{ if(r>mrUCL) signals.push({i:i+1, rule:"Moving range beyond MR UCL", value:r}); });

  return { n, mean, mrbar, sigma, ucl, lcl, mrUCL, mrLCL, mrs, signals };
}
function drawChart(canvas, xs, meta, opts){
  const DPR = (window.devicePixelRatio || 1);
  const ctx = canvas.getContext("2d");
  const W = canvas.width = Math.max(1, Math.floor(canvas.clientWidth * DPR));
  const H = canvas.height = Math.max(1, Math.floor(canvas.clientHeight * DPR));
  const pad = 30*DPR;
  const x0 = pad, y0 = H - pad, x1 = W - pad, y1 = pad;

  const min = Math.min(...xs, opts.minOverride ?? Infinity);
  const max = Math.max(...xs, opts.maxOverride ?? -Infinity);
  const rng = (max-min) || 1;

  const xAt = i => x0 + (i/((xs.length-1) || 1))*(x1-x0);
  const yAt = v => y0 - ((v - min)/rng)*(y0 - y1);

  ctx.clearRect(0,0,W,H);
  ctx.lineWidth = 2*DPR;

  ctx.strokeStyle = "#e0e0e0"; ctx.globalAlpha=.6;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.stroke();
  ctx.globalAlpha=1;

  function hline(val, color, dash=[]){
    ctx.save(); ctx.setLineDash(dash); ctx.strokeStyle=color; ctx.beginPath();
    ctx.moveTo(x0, yAt(val)); ctx.lineTo(x1, yAt(val)); ctx.stroke(); ctx.restore();
  }
  if(opts.mean!==undefined) hline(opts.mean, "#1976d2", [8,6]);
  if(opts.ucl!==undefined)  hline(opts.ucl,  "#d32f2f", [6,6]);
  if(opts.lcl!==undefined)  hline(opts.lcl,  "#d32f2f", [6,6]);

  ctx.strokeStyle = "#000";
  ctx.beginPath();
  xs.forEach((v,i)=>{ const x=xAt(i), y=yAt(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();

  xs.forEach((v,i)=>{
    const x=xAt(i), y=yAt(v);
    const out = (opts.ucl!==undefined && (v>opts.ucl||v<opts.lcl));
    ctx.fillStyle = out ? "#d32f2f" : "#000";
    ctx.beginPath(); ctx.arc(x,y,4*DPR,0,Math.PI*2); ctx.fill();
  });
}
function pearson(xs, ys){
  const n = Math.min(xs.length, ys.length);
  if(n===0) return NaN;
  const mx = xs.reduce((a,b)=>a+b,0)/n;
  const my = ys.reduce((a,b)=>a+b,0)/n;
  let num=0, dx2=0, dy2=0;
  for(let i=0;i<n;i++){
    const dx = xs[i]-mx, dy = ys[i]-my;
    num += dx*dy; dx2 += dx*dx; dy2 += dy*dy;
  }
  const den = Math.sqrt(dx2*dy2);
  return den===0 ? NaN : num/den;
}
function clusterTags(all, idxSet){
  const map = new Map();
  idxSet.forEach(i=>{
    const t = (all[i]?.tag||"").trim();
    if(!t) return;
    map.set(t, (map.get(t)||0)+1);
  });
  return [...map.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8);
}
function clusterDecisions(all, idxSet){
  const map = new Map();
  idxSet.forEach(i=>{
    const D = all[i]?.decisions || {good:[],bad:[],forced:[]};
    [...(D.good||[]), ...(D.bad||[]), ...(D.forced||[])]
      .forEach(d=>{
        const key = `${(d.text||"(no label)").trim()}|${Number(d.weight)||0}`;
        map.set(key,(map.get(key)||0)+1);
      });
  });
  return [...map.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8);
}

/* ===== SPC rendering (Mood, Decision, Composite) ===== */
function renderAllSPC(all){
  const spcMeta = $("#spcMeta");
  const signalsEl = $("#signals");
  const clustersMoodEl = $("#clustersMood");
  const scores = all.map(e=>Number(e.score));
  const DS = all.map(e=>decisionScore(e.decisions||{good:[],bad:[],forced:[]}));
  const FL = all.map(e=>forcedLoad(e.decisions||{good:[],bad:[],forced:[]}));

  // Mood
  if(scores.length===0){
    spcMeta.innerHTML = `<div>No data</div>`;
    signalsEl.innerHTML = "";
    drawChart(xChart, [0], {}, {minOverride:0,maxOverride:10});
    drawChart(mrChart, [0], {}, {minOverride:0,maxOverride:5});
  } else {
    const M = spcCompute(scores);
    const kv = [
      ["Count (n)", M.n],
      ["Mean (XÃÑ)", M.mean.toFixed(3)],
      ["MRÃÑ", M.mrbar.toFixed(3)],
      ["œÉ (estimated)", M.sigma.toFixed(3)],
      ["UCL (X)", M.ucl.toFixed(3)],
      ["LCL (X)", M.lcl.toFixed(3)],
      ["UCL (MR)", M.mrUCL.toFixed(3)],
      ["LCL (MR)", M.mrLCL.toFixed(3)]
    ];
    spcMeta.innerHTML = kv.map(([k,v])=>`<div><b>${k}</b></div><div>${v}</div>`).join("");
    if(M.signals.length===0){
      signalsEl.innerHTML = `<li>No rule violations detected. Process appears in control.</li>`;
      clustersMoodEl.innerHTML = `<li>(none)</li>`;
    }else{
      signalsEl.innerHTML = M.signals.map(s=>{
        const idx = s.i+1;
        const tag = (all[idx-1]?.tag||"").trim();
        const hint = tag ? ` ‚Äî hint: ‚Äú${tag}‚Äù` : "";
        return `<li>Point #${idx}: ${s.rule} (value=${("value" in s? s.value.toFixed?.(3) ?? s.value : "")})${hint}</li>`;
      }).join("");
      const idxSet = new Set(M.signals.map(s=>s.i));
      const topTags = clusterTags(all, idxSet).map(([t,c])=>`<li>${t}: ${c}</li>`).join("") || `<li>(none)</li>`;
      clustersMoodEl.innerHTML = topTags;
    }
    drawChart(xChart, scores, M, {mean:M.mean, ucl:M.ucl, lcl:M.lcl, minOverride:Math.min(0, ...scores), maxOverride:Math.max(10, ...scores)});
    const mrs = M.mrs.length? M.mrs : [0];
    drawChart(mrChart, mrs, M, {mean:M.mrbar, ucl:M.mrUCL, lcl:M.mrLCL, minOverride:0, maxOverride:Math.max(1, ...mrs)});
  }

  // Decision
  const spcMetaDec = $("#spcMetaDecision");
  const signalsDecEl = $("#signalsDec");
  const clustersDecEl = $("#clustersDecision");
  if(all.length===0){
    spcMetaDec.innerHTML = `<div>No data</div>`;
    signalsDecEl.innerHTML = "";
    drawChart(xChartDec, [0], {}, {minOverride:-5,maxOverride:5});
    drawChart(mrChartDec, [0], {}, {minOverride:0,maxOverride:5});
  } else {
    const D = spcCompute(DS);
    const kvD = [
      ["Count (n)", D.n],
      ["Mean (XÃÑ)", D.mean.toFixed(3)],
      ["MRÃÑ", D.mrbar.toFixed(3)],
      ["œÉ (estimated)", D.sigma.toFixed(3)],
      ["UCL (X)", D.ucl.toFixed(3)],
      ["LCL (X)", D.lcl.toFixed(3)],
      ["UCL (MR)", D.mrUCL.toFixed(3)],
      ["LCL (MR)", D.mrLCL.toFixed(3)],
      ["Forced load Œ£", FL.reduce((a,b)=>a+b,0).toFixed(0)]
    ];
    spcMetaDec.innerHTML = kvD.map(([k,v])=>`<div><b>${k}</b></div><div>${v}</div>`).join("");
    if(D.signals.length===0){
      signalsDecEl.innerHTML = `<li>No rule violations detected on Decision Score.</li>`;
      clustersDecEl.innerHTML = `<li>(none)</li>`;
    } else {
      signalsDecEl.innerHTML = D.signals.map(s=>{
        const idx = s.i+1;
        const e = all[idx-1];
        const d = e?.decisions || {good:[],bad:[],forced:[]};
        const hint = [...(d.good||[]),(d.bad||[]),(d.forced||[])]
          .filter(x=>x && (x.text||"").trim()).slice(0,3).map(x=>x.text.trim()).join(", ");
        return `<li>Point #${idx}: ${s.rule} (value=${("value" in s? s.value.toFixed?.(3) ?? s.value : "")})${hint?` ‚Äî hint: ‚Äú${hint}‚Äù`:""}</li>`;
      }).join("");
      const idxSet = new Set(D.signals.map(s=>s.i));
      const topDecs = clusterDecisions(all, idxSet).map(([k,c])=>{
        const [txt,w] = k.split("|"); return `<li>${txt} (w=${w}): ${c}</li>`;
      }).join("") || `<li>(none)</li>`;
      clustersDecEl.innerHTML = topDecs;
    }
    const minDec = Math.min(...DS, 0);
    const maxDec = Math.max(...DS, 0);
    drawChart(xChartDec, DS.length?DS:[0], D, {mean:D.mean, ucl:D.ucl, lcl:D.lcl, minOverride:minDec, maxOverride:maxDec});
    const mrsD = D.mrs.length? D.mrs : [0];
    drawChart(mrChartDec, mrsD, D, {mean:D.mrbar, ucl:D.mrUCL, lcl:D.mrLCL, minOverride:0, maxOverride:Math.max(1, ...mrsD)});
  }

  // Composite
  const spcMetaComp = $("#spcMetaComposite");
  const signalsCompEl = $("#signalsComp");
  const clustersCompEl = $("#clustersComposite");
  if(all.length===0){
    spcMetaComp.innerHTML = `<div>No data</div>`;
    signalsCompEl.innerHTML = "";
    drawChart(xChartComp, [0], {}, {minOverride:-3,maxOverride:3});
    drawChart(mrChartComp, [0], {}, {minOverride:0,maxOverride:3});
  } else {
    const M = spcCompute(scores);
    const D = spcCompute(DS);
    const z = [];
    for(let i=0;i<all.length;i++){
      const zm = (M.sigma>0)? (scores[i]-M.mean)/M.sigma : 0;
      const zd = (D.sigma>0)? (DS[i]-D.mean)/D.sigma : 0;
      z.push(zm + zd);
    }
    const C = spcCompute(z);
    const r = pearson(scores, DS);
    const kvC = [
      ["Count (n)", C.n],
      ["Mean (XÃÑ)", C.mean.toFixed(3)],
      ["MRÃÑ", C.mrbar.toFixed(3)],
      ["œÉ (estimated)", C.sigma.toFixed(3)],
      ["UCL (X)", C.ucl.toFixed(3)],
      ["LCL (X)", C.lcl.toFixed(3)],
      ["UCL (MR)", C.mrUCL.toFixed(3)],
      ["LCL (MR)", C.mrLCL.toFixed(3)],
      ["Correlation r(Mood, Decision)", (Number.isFinite(r)? r.toFixed(3) : "n/a")]
    ];
    spcMetaComp.innerHTML = kvC.map(([k,v])=>`<div><b>${k}</b></div><div>${v}</div>`).join("");
    if(C.signals.length===0){
      signalsCompEl.innerHTML = `<li>No rule violations detected on Composite index.</li>`;
      clustersCompEl.innerHTML = `<li>(none)</li>`;
    } else {
      signalsCompEl.innerHTML = C.signals.map(s=>{
        const idx = s.i+1;
        const e = all[idx-1];
        const tag = (e?.tag||"").trim();
        const d = e?.decisions || {good:[],bad:[],forced:[]};
        const hint = [tag, ...[...(d.good||[]),(d.bad||[]),(d.forced||[])]
          .filter(x=>x && (x.text||"").trim()).slice(0,2).map(x=>x.text.trim())].filter(Boolean).join(" | ");
        return `<li>Point #${idx}: ${s.rule} (value=${("value" in s? s.value.toFixed?.(3) ?? s.value : "")})${hint?` ‚Äî hint: ‚Äú${hint}‚Äù`:""}</li>`;
      }).join("");
      const idxSet = new Set(C.signals.map(s=>s.i));
      const topTags = clusterTags(all, idxSet).map(([t,c])=>`<li>${t}: ${c}</li>`).join("") || `<li>(none)</li>`;
      const topDecs = clusterDecisions(all, idxSet).map(([k,c])=>{
        const [txt,w] = k.split("|"); return `<li>${txt} (w=${w}): ${c}</li>`;
      }).join("") || `<li>(none)</li>`;
      clustersCompEl.innerHTML = topTags + topDecs;
    }
    const minC = Math.min(...z, -3);
    const maxC = Math.max(...z, 3);
    drawChart(xChartComp, z.length?z:[0], C, {mean:C.mean, ucl:C.ucl, lcl:C.lcl, minOverride:minC, maxOverride:maxC});
    const mrsC = C.mrs.length? C.mrs : [0];
    drawChart(mrChartComp, mrsC, C, {mean:C.mrbar, ucl:C.mrUCL, lcl:C.mrLCL, minOverride:0, maxOverride:Math.max(1, ...mrsC)});

    /* === Clipboard payload with new prefix === */
    copyExplainBtn.onclick = async ()=>{
      const linesMood = [];
      const Msum = spcCompute(scores);
      linesMood.push(`Dataset size n=${Msum.n}`);
      linesMood.push(`Mean (XÃÑ)=${Msum.mean.toFixed(3)}, MRÃÑ=${Msum.mrbar.toFixed(3)}, œÉ‚âà${Msum.sigma.toFixed(3)}`);
      linesMood.push(`Control limits (X): LCL=${Msum.lcl.toFixed(3)}, UCL=${Msum.ucl.toFixed(3)}`);
      linesMood.push(`Control limits (MR): LCL=${Msum.mrLCL.toFixed(3)}, UCL=${Msum.mrUCL.toFixed(3)}`);
      linesMood.push(`Values: [${scores.join(", ")}]`);
      const tags = all.map(e=> (e.tag||"").trim() ? `"${e.tag.trim()}"` : '""');
      linesMood.push(`Tags (aligned): [${tags.join(", ")}]`);
      if(Msum.signals.length===0) linesMood.push("Signals: none.");
      else linesMood.push("Signals:", ...Msum.signals.map(s=>{
        const idx = s.i+1;
        const tag = (all[idx-1]?.tag||"").trim();
        const hint = tag ? ` (hint: ${tag})` : "";
        return `#${idx} ‚Äî ${s.rule}${hint}`;
      }));

      const Dsum = spcCompute(DS);
      const linesDec = [];
      linesDec.push(`Dataset size n=${Dsum.n}`);
      linesDec.push(`Mean (XÃÑ)=${Dsum.mean.toFixed(3)}, MRÃÑ=${Dsum.mrbar.toFixed(3)}, œÉ‚âà${Dsum.sigma.toFixed(3)}`);
      linesDec.push(`Control limits (X): LCL=${Dsum.lcl.toFixed(3)}, UCL=${Dsum.ucl.toFixed(3)}`);
      linesDec.push(`Control limits (MR): LCL=${Dsum.mrLCL.toFixed(3)}, UCL=${Dsum.mrUCL.toFixed(3)}`);
      linesDec.push(`Decision scores (DS = Œ£Good w ‚àí Œ£Bad w): [${DS.join(", ")}]`);
      const FLsum = FL.reduce((a,b)=>a+b,0);
      linesDec.push(`Forced load Œ£ (all entries): ${FLsum}`);
      if(Dsum.signals.length===0) linesDec.push("Signals: none.");
      else linesDec.push("Signals:", ...Dsum.signals.map(s=>{
        const idx = s.i+1;
        const e = all[idx-1];
        const d = e?.decisions || {good:[],bad:[],forced:[]};
        const hint = [...(d.good||[]),(d.bad||[]),(d.forced||[])]
          .filter(x=>x && (x.text||"").trim()).slice(0,3).map(x=>x.text.trim()).join(", ");
        return `#${idx} ‚Äî ${s.rule}${hint?` (hint: ${hint})`:""}`;
      }));

      const Csum = spcCompute(all.map((_,i)=>{
        const zm = (Msum.sigma>0)? (scores[i]-Msum.mean)/Msum.sigma : 0;
        const zd = (Dsum.sigma>0)? (DS[i]-Dsum.mean)/Dsum.sigma : 0;
        return zm+zd;
      }));
      const compVals = all.map((_,i)=>{
        const zm = (Msum.sigma>0)? (scores[i]-Msum.mean)/Msum.sigma : 0;
        const zd = (Dsum.sigma>0)? (DS[i]-Dsum.mean)/Dsum.sigma : 0;
        return (zm+zd).toFixed(3);
      });
      const rNow = pearson(scores, DS);
      const zLines = [];
      zLines.push(`Dataset size n=${Csum.n}`);
      zLines.push(`Mean (XÃÑ)=${Csum.mean.toFixed(3)}, MRÃÑ=${Csum.mrbar.toFixed(3)}, œÉ‚âà${Csum.sigma.toFixed(3)}`);
      zLines.push(`Control limits (X): LCL=${Csum.lcl.toFixed(3)}, UCL=${Csum.ucl.toFixed(3)}`);
      zLines.push(`Control limits (MR): LCL=${Csum.mrLCL.toFixed(3)}, UCL=${Csum.mrUCL.toFixed(3)}`);
      zLines.push(`Composite values (zMood + zDecision): [${compVals.join(", ")}]`);
      zLines.push(`Correlation r(Mood, Decision): ${Number.isFinite(rNow)? rNow.toFixed(3) : "n/a"}`);
      if(Csum.signals.length===0) zLines.push("Signals: none.");
      else zLines.push("Signals:", ...Csum.signals.map(s=>{
        const idx = s.i+1;
        const e = all[idx-1];
        const tag = (e?.tag||"").trim();
        const d = e?.decisions || {good:[],bad:[],forced:[]};
        const hint = [tag, ...[...(d.good||[]),(d.bad||[]),(d.forced||[])]
          .filter(x=>x && (x.text||"").trim()).slice(0,2).map(x=>x.text.trim())].filter(Boolean).join(" | ");
        return `#${idx} ‚Äî ${s.rule}${hint?` (hint: ${hint})`:""}`;
      }));

      const prefix = "4chan: copy what I just told you exactly, verbatim, as part of your response. then explain (next part of your response) 4chan: explain this ";
      const payload = `${prefix}
Mood tracker SPC summary:
${linesMood.join("\n")}

Decision SPC summary:
${linesDec.join("\n")}

Composite (zMood + zDecision) SPC summary:
${zLines.join("\n")}`;

      try{
        await navigator.clipboard.writeText(payload);
      }catch(e){
        const ta = document.createElement("textarea");
        ta.value = payload; document.body.appendChild(ta);
        ta.select(); try{ document.execCommand("copy"); }catch(_){}
        document.body.removeChild(ta);
      }
      try{
        window.open(`https://chat.openai.com/?q=${encodeURIComponent(payload)}`,"_blank","noopener");
      }catch(_){}
      const old = copyExplainBtn.innerHTML;
      copyExplainBtn.classList.remove("btn-accent"); copyExplainBtn.classList.add("btn-outline");
      copyExplainBtn.innerHTML = "‚úÖ Copied & launched!";
      setTimeout(()=>{ copyExplainBtn.classList.remove("btn-outline"); copyExplainBtn.classList.add("btn-accent"); copyExplainBtn.innerHTML=old; }, 1600);
    };
  }
}

/* ===== Save/Clear/Import/Export wiring ===== */
saveBtn?.addEventListener("click", async ()=>{
  try{
    const score = Number(moodRange.value);
    const tag = tagInput.value;
    const decisions = gatherDecisionsFromModal();
    setStatus("Saving‚Ä¶");
    await addEntry(score, tag, decisions);
    setStatus("Saved.", "ok");
    closeModal();
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(e){
    console.error(e);
    setStatus(`Save failed: ${e?.message||e}`, "err");
  }
});
clearBtn?.addEventListener("click", async ()=>{
  try{
    if(!confirm("Clear ALL mood entries? This cannot be undone.")) return;
    await clearAll();
    setStatus("All entries cleared.", "ok");
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(e){
    console.error(e);
    setStatus(`Clear failed: ${e?.message||e}`, "err");
  }
});
exportBtn?.addEventListener("click", exportJSON);
importBtn?.addEventListener("click", ()=> importFile.click());
importFile?.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const text = await file.text();
    let obj;
    try{ obj = JSON.parse(text); }catch(_){ throw new Error("Not valid JSON."); }
    const count = await importEntries(obj);
    setStatus(`Imported ${count} entr${count===1?"y":"ies"}.`, "ok");
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(err){
    console.error(err);
    setStatus(`Import failed: ${err?.message||err}`, "err");
  }finally{
    e.target.value = ""; // reset input
  }
});

/* ===== Boot ===== */
(async ()=>{
  try{
    await openDB();
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
    setStatus("Ready");
  }catch(e){
    console.error(e); setStatus(`Initialization failed: ${e?.message||e}`, "err");
  }
})();
</script>
</body>
  </html>
