<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adaptive Weighted Redirect (Crypto RNG + Memory Drift + Dynamic Blend)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; }
    code { background: #f2f2f2; padding: 0.1rem 0.3rem; border-radius: 4px; }
  </style>
  <script>
    (function () {
      // --- Crypto RNG helpers
      function cryptoRandom() {
        const buf = new Uint32Array(1);
        window.crypto.getRandomValues(buf);
        return buf[0] / 0xffffffff;
      }
      function cryptoNormal(mean = 0, stdDev = 1) {
        let u1 = 0, u2 = 0;
        while (u1 === 0) u1 = cryptoRandom();
        while (u2 === 0) u2 = cryptoRandom();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return z0 * stdDev + mean;
      }

      // --- Core configuration (unchanged)
      const urls = [
        "https://sktoushi.github.io/su/all-classic2025.html", 
        "https://sktoushi.github.io/su/all.html",          // base 50%
        "https://sktoushi.github.io/su/allrecent.html",    // base 30%
        "https://sktoushi.github.io/su/allrecent100.html"  // base 20%
      ];
      const baseWeights = [0.25, 0.25, 0.3, 0.2];

      // --- Load past stats
      const memoryKey = "redirect_memory_v1";
      let history = JSON.parse(localStorage.getItem(memoryKey) || "{}");
      let counts = history.counts || [0, 0, 0];
      // add per-index lastSeen support (preserves existing storage)
      let lastSeen = history.lastSeen || {}; // { 0: ts, 1: ts, 2: ts }
      let totalVisits = counts.reduce((a, b) => a + b, 0);

      // --- Compute adaptive bias (favor under-visited links)
      let bias = [0, 0, 0];
      if (totalVisits > 0) {
        const avg = totalVisits / counts.length;
        bias = counts.map(c => (avg - c) / avg * 0.1); // up to ±10% adaptive bias
      }

      // --- Determine noise volatility
      const erratic = cryptoRandom() < 0.1; // 10% chance for erratic mode
      const noiseStdDev = erratic ? 0.25 : 0.05;

      // --- Apply crypto noise and bias (BASE)
      const base = baseWeights.map((w, i) => {
        const noise = cryptoNormal(0, noiseStdDev) * w;
        const adaptive = bias[i] || 0;
        return Math.max(0, w + noise + adaptive);
      });

      // --- Dynamic blend: deja gate + entropy-based beta (base always dominates)
      function dejaGate(nowMs) {
        const d = new Date(nowMs);
        const hour = d.getHours() + d.getMinutes()/60; // 0..24
        const day  = d.getDay();                       // 0..6
        const daily  = 0.5 * (1 + Math.sin((2*Math.PI)*(hour/24 - 0.25)));
        const weekly = 0.5 * (1 + Math.cos((2*Math.PI)*((day+0.5)/7)));
        const u = new Uint32Array(1); window.crypto.getRandomValues(u);
        const jitter = (u[0] / 0xffffffff) * 0.2;
        const g = 0.45*daily + 0.35*weekly + jitter;
        return Math.min(1, Math.max(0, g));
      }

      const now = Date.now();

      // Cohort mean gap for deja targeting
      const seenDeltas = [0,1,2]
        .map(i => lastSeen[i])
        .filter(ts => typeof ts === 'number')
        .map(ts => now - ts);
      const meanDelta = seenDeltas.length
        ? (seenDeltas.reduce((a,b)=>a+b,0) / seenDeltas.length)
        : null;

      // Per-option deja multiplier (soft Gaussian around cohort mean gap)
      const dejaMults = [0,1,2].map(i => {
        const ts = lastSeen[i];
        if (typeof ts !== 'number' || meanDelta == null || meanDelta <= 0) return 1;
        const delta = now - ts;
        const sigma = meanDelta;                  // broad width from cohort itself
        const x = (delta - meanDelta) / (sigma || 1);
        const due = Math.exp(-(x * x));          // 0..1
        return 1 + due;                           // ∈ [1, 2]
      });

      // Base distribution entropy (normalized 0..1)
      const baseSum = base.reduce((a,b)=>a+b, 0) || 1;
      const p = base.map(v => v / baseSum);
      let H = 0; for (let i=0;i<p.length;i++) if (p[i] > 0) H -= p[i] * Math.log(p[i]);
      const Hnorm = (p.length > 1) ? (H / Math.log(p.length)) : 0;

      // Dynamic beta in (0, 0.5) so base dominates without a fixed cap exposed
      let beta;
      {
        const g = dejaGate(now); // 0..1
        const u = new Uint32Array(1); window.crypto.getRandomValues(u);
        const j = (u[0] / 0xffffffff); // 0..1 jitter
        beta = 0.5 * g * (1 - Hnorm) * (0.75 + 0.25*j);
        if (beta >= 0.5) beta = 0.499;
        if (beta < 0) beta = 0;
      }

      // --- Blend base with deja multipliers (convex combo; base stays dominant)
      let blended = base.map((b, i) => Math.max(1e-12, b * ((1 - beta) + beta * (dejaMults[i] || 1))));

      // --- Normalize to sum = 1
      const sum = blended.reduce((a, b) => a + b, 0) || 1;
      const noisyWeights = blended.map(w => w / sum);

      // --- Choose target with crypto RNG
      const thresholds = [noisyWeights[0], noisyWeights[0] + noisyWeights[1], 1.0];
      const r = cryptoRandom();
      let chosenIndex;
      if (r < thresholds[0]) chosenIndex = 0;
      else if (r < thresholds[1]) chosenIndex = 1;
      else chosenIndex = 2;

      const target = urls[chosenIndex];

      // --- Update and persist memory (counts + lastSeen)
      counts[chosenIndex] = (counts[chosenIndex] || 0) + 1;
      lastSeen[chosenIndex] = now;
      localStorage.setItem(memoryKey, JSON.stringify({ counts, lastSeen }));

      // --- Redirect immediately
      window.location.replace(target);

      // --- Display diagnostic info if JS visible
      document.addEventListener("DOMContentLoaded", function () {
        const a = document.getElementById("target-link");
        if (a) a.href = target;
        const pre = document.getElementById("picked");
        if (pre) {
          const info =
            `weights: ${noisyWeights.map(w => (w * 100).toFixed(1) + "%").join(" / ")} | ` +
            (erratic ? "⚡ erratic mode" : "⤵ stable mode") +
            ` | visits: [${counts.join(", ")}]`;
          pre.textContent = target + " (" + info + ")";
        }
      });
    })();
  </script>
  <noscript>
    <meta http-equiv="refresh" content="0; url=https://sktoushi.github.io/su/all.html">
  </noscript>
</head>
<body>
  <h1>Redirecting…</h1>
  <p>If you’re not redirected automatically, <a id="target-link" href="https://sktoushi.github.io/su/all.html">click here</a>.</p>
  <p><small>Picked URL: <code id="picked">calculating…</code></small></p>
</body>
</html>
