<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Repository Issue Randomizer (Crypto RNG, No Loop)</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Original styles (kept) */
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #fafafa;
      margin: 2rem;
    }
    code {
      background: #eee;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
    }
    a { word-break: break-all; }

    /* ===== Themed modal (kept) ===== */
    :root {
      --bg:#0b0c10; --fg:#cfd8dc; --muted:#90a4ae; --accent:#7cb342;
      --btn:#263238; --btn-hover:#37474f; --btn-active:#455a64; --danger:#e53935;
    }
    .hidden{display:none!important;}
    .small{color:var(--muted); font-size:.9rem;}
    .toolbar{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .btn{
      border:1px solid #111; background:var(--btn); color:var(--fg);
      padding:.6rem 1rem; border-radius:.5rem; font-size:1rem; cursor:pointer;
      transition: transform .05s ease, background .15s ease, box-shadow .15s ease;
      box-shadow:0 2px 0 rgba(0,0,0,.3); user-select:none;
    }
    .btn:hover{background:var(--btn-hover);}
    .btn:active{transform:translateY(1px); background:var(--btn-active);}
    .btn[disabled]{opacity:.5; cursor:not-allowed;}
    .btn-accent{background:var(--accent); color:#0b0c10; border-color:#5a8e2f;}
    .btn-danger{background:var(--danger); color:#fff; border-color:#b71c1c;}
    .btn-small{padding:.45rem .7rem; font-size:.95rem; border-radius:.45rem;}

    dialog{
      border:none; border-radius:12px; padding:0; background:#11161a; color:var(--fg);
      width:min(560px,92vw);
      box-shadow:0 20px 60px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.05) inset;
    }
    dialog::backdrop{background:rgba(0,0,0,.6);}
    .modal{padding:1.25rem 1.25rem 1rem;}
    .modal h2{margin:0 0 .25rem 0; font-weight:700; font-size:1.2rem;}
    .modal p{margin:0 0 1rem 0; color:var(--muted);}

    .field{
      display:grid; grid-template-columns:1fr auto; gap:.75rem; align-items:center;
      margin:.75rem 0 1rem 0;
    }
    .numinput{
      width:12ch; padding:.6rem .75rem; border-radius:.5rem; border:1px solid rgba(255,255,255,.08);
      background:#0f1519; color:var(--fg); font-size:1rem;
    }
    .hint{margin-top:-.6rem; margin-bottom:.9rem;}

    /* New: tiny layout helper for +/- frequency control */
    .freqrow{display:flex; align-items:center; gap:.5rem;}
    .freqbadge{
      padding:.35rem .6rem; border:1px solid rgba(255,255,255,.08); border-radius:.5rem;
      background:#0f1519; color:var(--fg); font-variant-numeric:tabular-nums;
      min-width:7ch; text-align:center;
    }
  </style>
</head>
<body>

<!-- Themed modal asking for issueEndNumber -->
<dialog id="endDialog" aria-labelledby="endDialogTitle">
  <div class="modal">
    <h2 id="endDialogTitle">Set <code>issueEndNumber</code></h2>
    <p>Enter the highest issue number to use when picking a random issue. This value is saved in <code>IndexedDB</code> and used from now on.</p>

    <div class="field">
      <label for="endInput" class="small">issueEndNumber</label>
      <input id="endInput" class="numinput" type="number" min="1" step="1" inputmode="numeric" pattern="[0-9]*" />
    </div>
    <div id="endError" class="small hidden" style="color:#ff8a80;">Please enter a positive integer (≥ 1).</div>
    <div class="hint small">If you skip, we’ll continue using the current stored value (seeded from the config on first run).</div>

    <!-- ▼ Updated: frequency controls (±5 minutes, min 5), placed right before the buttons -->
    <div class="field">
      <label class="small">Modal frequency</label>
      <div class="freqrow">
        <button id="freqDec" type="button" class="btn btn-small" aria-label="Decrease by 5 minutes">−5m</button>
        <span id="freqValue" class="freqbadge small">10 min</span>
        <button id="freqInc" type="button" class="btn btn-small" aria-label="Increase by 5 minutes">+5m</button>
      </div>
    </div>
    <div class="small hint">We’ll still show this at least once every 15 minutes.</div>
    <!-- ▲ End new controls -->

    <div class="toolbar" style="margin-top:.6rem;">
      <button class="btn btn-small btn-danger" id="skipEndBtn">Skip</button>
      <div style="flex:1"></div>
      <button class="btn btn-small" id="resetEndBtn" title="Reset to config value">Reset</button>
      <button class="btn btn-accent btn-small" id="saveEndBtn">Save & Continue</button>
    </div>
  </div>
</dialog>

<script>
/* ============================================================
   Crypto-secure randomness only (no Math.random)
   Steps:
   1) Load config/all.json
   2) Extract the LAST repository entry (in insertion order)
   3) Pick a random issue in [Math.max(1, end - 100), end] using crypto RNG
   4) Redirect immediately to the chosen issue URL
   ============================================================ */

(function () {
  const TWO32 = 0x100000000; // 2^32

  function assertCrypto() {
    if (!window.crypto || !window.crypto.getRandomValues) {
      throw new Error('Secure RNG unavailable: window.crypto.getRandomValues not found.');
    }
  }

  // Uniform float in [0, 1)
  function cryptoRandomFloat() {
    assertCrypto();
    const buf = new Uint32Array(1);
    window.crypto.getRandomValues(buf);
    return buf[0] / TWO32;
  }

  // Uniform integer in [min, max] without modulo bias (rejection sampling)
  function cryptoRandomInt(min, max) {
    assertCrypto();
    if (!Number.isInteger(min) || !Number.isInteger(max) || max < min) {
      throw new Error('Invalid range for cryptoRandomInt.');
    }
    const range = max - min + 1;
    const limit = TWO32 - (TWO32 % range); // Largest multiple of range less than 2^32
    const buf = new Uint32Array(1);
    let x;
    do {
      window.crypto.getRandomValues(buf);
      x = buf[0];
    } while (x >= limit);
    return min + (x % range);
  }

  // >>> pick the LAST repository object <<<
  function extractFinalRepo(repositories) {
    if (!repositories || typeof repositories !== 'object') {
      throw new Error('Invalid repositories structure in config.');
    }

    // Case A: already a single final object: { repo, username, issueEndNumber }
    if ('repo' in repositories && 'username' in repositories && 'issueEndNumber' in repositories) {
      return {
        repo: String(repositories.repo),
        username: String(repositories.username),
        issueEndNumber: Number(repositories.issueEndNumber)
      };
    }

    // Case B: mapping of repoName -> info. Pick the LAST entry (in insertion order).
    const entries = Object.entries(repositories);
    if (entries.length === 0) throw new Error('No repositories configured.');

    const [repoName, info] = entries[entries.length - 1]; // last one

    if (!info || typeof info !== 'object') throw new Error('Malformed repository info.');
    if (!info.username) throw new Error('Missing "username" in repository info.');
    if (info.issueEndNumber == null) throw new Error('Missing "issueEndNumber" in repository info.');

    return {
      repo: String(repoName),
      username: String(info.username),
      issueEndNumber: Number(info.issueEndNumber)
    };
  }

  /* ================= IndexedDB (same DB + keys) ================= */
  const IDB_NAME = 'issueEndOverrideDB_v1';
  const IDB_VER = 1;
  const STORE_SETTINGS = 'settings';
  const KEY_END = 'overrideIssueEndNumber';
  const KEY_LAST_MODAL = 'lastEndModalShown';
  const KEY_FREQ_MINUTES = 'modalFreqMinutes';

  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_NAME, IDB_VER);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(STORE_SETTINGS)) db.createObjectStore(STORE_SETTINGS);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  function idbGet(key) {
    return openDB().then(db => new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_SETTINGS, 'readonly');
      const st = tx.objectStore(STORE_SETTINGS);
      const r = st.get(key);
      r.onsuccess = () => resolve(r.result);
      r.onerror = () => reject(r.error);
    }));
  }
  function idbSet(key, value) {
    return openDB().then(db => new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_SETTINGS, 'readwrite');
      const st = tx.objectStore(STORE_SETTINGS);
      const r = st.put(value, key);
      r.onsuccess = () => resolve(true);
      r.onerror = () => reject(r.error);
    }));
  }

  /* ===== Modal helpers (timing: occasional + throttled) ===== */
  const FORCED_MIN_INTERVAL_MS = 15 * 60 * 1000; // hard guarantee
  const DEFAULT_USER_INTERVAL_MS = 10 * 60 * 1000; // default 10min
  const MODAL_SHOW_PROBABILITY = 0.15; // soft attempts between forced intervals
  const USER_MIN_FREQ_MINUTES = 5; // floor: 5 minutes
  const STEP_MINUTES = 5; // increment/decrement step

  function roundToStep(valueMinutes) {
    // Round to nearest 5, with floor at 5
    const v = Math.max(USER_MIN_FREQ_MINUTES, Math.round(valueMinutes / STEP_MINUTES) * STEP_MINUTES);
    return v;
  }

  function maybeShowEndModal(prefill, freqMinutes, onSave, onSkip) {
    const dlg = document.getElementById('endDialog');
    const input = document.getElementById('endInput');
    const err = document.getElementById('endError');
    const btnSave = document.getElementById('saveEndBtn');
    const btnSkip = document.getElementById('skipEndBtn');
    const btnReset = document.getElementById('resetEndBtn');

    // New freq controls
    const freqDec = document.getElementById('freqDec');
    const freqInc = document.getElementById('freqInc');
    const freqValue = document.getElementById('freqValue');

    input.value = String(prefill || 1);
    err.classList.add('hidden');

    let currentFreq = roundToStep(Number(freqMinutes) || (DEFAULT_USER_INTERVAL_MS / 60000));
    function renderFreq() {
      freqValue.textContent = `${currentFreq} min`;
    }
    renderFreq();

    freqDec.onclick = () => {
      currentFreq = Math.max(USER_MIN_FREQ_MINUTES, currentFreq - STEP_MINUTES);
      renderFreq();
    };
    freqInc.onclick = () => {
      currentFreq = currentFreq + STEP_MINUTES; // no explicit max
      renderFreq();
    };

    const validate = () => {
      const v = Number(input.value);
      if (!Number.isInteger(v) || v < 1) {
        err.classList.remove('hidden');
        return null;
      }
      err.classList.add('hidden');
      return v;
    };

    btnSave.onclick = () => {
      const v = validate();
      if (v == null) return;
      try { dlg.close(); } catch {}
      onSave(v, currentFreq);
    };
    btnSkip.onclick = () => {
      try { dlg.close(); } catch {}
      onSkip && onSkip(currentFreq);
    };
    btnReset.onclick = () => {
      input.value = String(prefill || 1);
      err.classList.add('hidden');
      // do not change frequency on reset; it's only for issueEndNumber
    };

    try { dlg.showModal(); } catch { dlg.show(); }
  }

  async function main() {
    const res = await fetch('config/all.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('Failed to load config');
    const cfg = await res.json();

    const reposRaw = cfg.repositories || cfg.repository || cfg.repo || {};
    const finalRepo = extractFinalRepo(reposRaw);

    // Seed IDB override with config value on first run; then always read from IDB
    let endOverride = await idbGet(KEY_END);
    if (typeof endOverride !== 'number' || !Number.isFinite(endOverride) || endOverride < 1) {
      await idbSet(KEY_END, Number(finalRepo.issueEndNumber));
      endOverride = Number(finalRepo.issueEndNumber);
    }

    // Load (or seed) user frequency in minutes; clamp to 5-min steps with 5-min floor
    let freqMinutes = await idbGet(KEY_FREQ_MINUTES);
    if (typeof freqMinutes !== 'number' || !Number.isFinite(freqMinutes) || freqMinutes <= 0) {
      freqMinutes = DEFAULT_USER_INTERVAL_MS / 60000; // default 10
    }
    freqMinutes = roundToStep(freqMinutes);
    await idbSet(KEY_FREQ_MINUTES, freqMinutes);

    const lastShown = await idbGet(KEY_LAST_MODAL);
    const now = Date.now();
    const elapsed = lastShown ? now - Number(lastShown) : Infinity;

    // Hard guarantee: if ≥15 min since last shown, force show
    const mustShow = elapsed >= FORCED_MIN_INTERVAL_MS;

    // Otherwise, soft rule: if ≥ user interval, maybe show based on probability
    const userIntervalMs = Number(freqMinutes) * 60 * 1000;
    const eligibleByUser = elapsed >= userIntervalMs;
    const wantsSoftShow = eligibleByUser && (cryptoRandomFloat() < MODAL_SHOW_PROBABILITY);

    const wantShow = mustShow || wantsSoftShow;

    if (wantShow) {
      // Record "shown" time immediately to uphold the 15-min guarantee even if skipped
      await idbSet(KEY_LAST_MODAL, now);

      maybeShowEndModal(
        endOverride,
        freqMinutes,
        async (pickedEnd, pickedFreqMinutes) => {
          await idbSet(KEY_END, Number(pickedEnd));
          await idbSet(KEY_FREQ_MINUTES, roundToStep(Number(pickedFreqMinutes)));
          await idbSet(KEY_LAST_MODAL, Date.now());
          proceed(Number(pickedEnd), finalRepo);
        },
        async (pickedFreqMinutes) => {
          // If user changed frequency then skipped, persist that choice too
          if (typeof pickedFreqMinutes === 'number' && Number.isFinite(pickedFreqMinutes)) {
            await idbSet(KEY_FREQ_MINUTES, roundToStep(Number(pickedFreqMinutes)));
          }
          proceed(Number(endOverride), finalRepo);
        }
      );
      return; // Wait for modal interaction to call proceed(...)
    }

    // No modal: proceed immediately using stored override
    proceed(Number(endOverride), finalRepo);
  }

  function proceed(endValue, finalRepo) {
    const end = Number(endValue);
    if (!Number.isFinite(end) || end < 1) throw new Error('Invalid issueEndNumber.');

    const lowerBound = Math.max(1, end - 100);
    const randomChosenNumber = cryptoRandomInt(lowerBound, end);

    const user = finalRepo.username;
    const repo = finalRepo.repo;
    const chosenUrl = `https://github.com/${user}/${repo}/issues/${randomChosenNumber}`;

    // Redirect immediately
    location.href = chosenUrl;

    // Fallback UI if redirect is blocked
    document.addEventListener('DOMContentLoaded', () => {
      const wrap = document.createElement('div');
      const h = document.createElement('h2');
      h.textContent = 'Redirecting to a random issue…';
      const p = document.createElement('p');
      p.innerHTML = `Selected range: <code>[${lowerBound}, ${end}]</code><br/>
                     Chosen issue: <code>#${randomChosenNumber}</code><br/>
                     Repository: <code>${user}/${repo}</code><br/>
                     Link: <a href="${chosenUrl}">${chosenUrl}</a>`;
      wrap.appendChild(h);
      wrap.appendChild(p);
      document.body.appendChild(wrap);
    });
  }

  main().catch(err => {
    document.body.textContent = err.message;
  });
})();
</script>

</body>
</html>
