<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Repository Issue Randomizer (Crypto RNG, Dynamic Blend)</title>
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #fafafa;
      margin: 2rem;
    }
    code { background:#eee; padding:0.15rem 0.4rem; border-radius:4px; }
    a { word-break: break-all; }
  </style>
</head>
<body>

<script>
/* ============================================================
   Crypto-secure randomness only (no Math.random)
   Now with dynamic blend that never outweighs the base.
   Steps:
   1) Load config/all.json
   2) Extract the LAST repository entry (in insertion order)
   3) Build uniform base over [max(1,end-100), end]
   4) Compute a gentle déjà-vu multiplier from lastSeen deltas
   5) Blend dynamically with beta < 0.5 (base always dominates)
   6) Sample via crypto RNG and redirect
   ============================================================ */

(function () {
  const TWO32 = 0x100000000;

  function assertCrypto() {
    if (!window.crypto || !window.crypto.getRandomValues) {
      throw new Error('Secure RNG unavailable: window.crypto.getRandomValues not found.');
    }
  }

  // Uniform float in [0, 1)
  function cryptoRandomFloat() {
    assertCrypto();
    const buf = new Uint32Array(1);
    window.crypto.getRandomValues(buf);
    return buf[0] / TWO32;
  }

  // Uniform int in [min, max] without modulo bias
  function cryptoRandomInt(min, max) {
    assertCrypto();
    if (!Number.isInteger(min) || !Number.isInteger(max) || max < min) {
      throw new Error('Invalid range for cryptoRandomInt.');
    }
    const range = max - min + 1;
    const limit = TWO32 - (TWO32 % range);
    const buf = new Uint32Array(1);
    let x;
    do {
      window.crypto.getRandomValues(buf);
      x = buf[0];
    } while (x >= limit);
    return min + (x % range);
  }

  // Pick the LAST repository entry
  function extractFinalRepo(repositories) {
    if (!repositories || typeof repositories !== 'object') {
      throw new Error('Invalid repositories structure in config.');
    }
    if ('repo' in repositories && 'username' in repositories && 'issueEndNumber' in repositories) {
      return {
        repo: String(repositories.repo),
        username: String(repositories.username),
        issueEndNumber: Number(repositories.issueEndNumber)
      };
    }
    const entries = Object.entries(repositories);
    if (entries.length === 0) throw new Error('No repositories configured.');
    const [repoName, info] = entries[entries.length - 1];
    if (!info || typeof info !== 'object') throw new Error('Malformed repository info.');
    if (!info.username) throw new Error('Missing "username" in repository info.');
    if (info.issueEndNumber == null) throw new Error('Missing "issueEndNumber" in repository info.');

    return {
      repo: String(repoName),
      username: String(info.username),
      issueEndNumber: Number(info.issueEndNumber)
    };
  }

  // Simple normal via Box–Muller
  function cryptoNormal(mean = 0, std = 1) {
    let u1 = 0, u2 = 0;
    while (u1 === 0) u1 = cryptoRandomFloat();
    while (u2 === 0) u2 = cryptoRandomFloat();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * std + mean;
  }

  // Time-varying gate in [0,1]
  function dejaGate(t) {
    const d = new Date(t);
    const hour = d.getHours() + d.getMinutes()/60;
    const day  = d.getDay();
    const daily  = 0.5 * (1 + Math.sin((2*Math.PI)*(hour/24 - 0.25)));
    const weekly = 0.5 * (1 + Math.cos((2*Math.PI)*((day+0.5)/7)));
    const u = new Uint32Array(1); window.crypto.getRandomValues(u);
    const jitter = (u[0] / 0xffffffff) * 0.2;
    const g = 0.45*daily + 0.35*weekly + jitter;
    return Math.min(1, Math.max(0, g));
  }

  // Weighted sample from probs[] (must sum ~1)
  function cryptoSampleIndex(probs) {
    let r = cryptoRandomFloat();
    let c = 0;
    for (let i = 0; i < probs.length; i++) {
      c += probs[i];
      if (r < c) return i;
    }
    return probs.length - 1;
  }

  async function main() {
    const res = await fetch('config/all.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('Failed to load config');
    const cfg = await res.json();

    const reposRaw = cfg.repositories || cfg.repository || cfg.repo || {};
    const finalRepo = extractFinalRepo(reposRaw);

    const end = Number(finalRepo.issueEndNumber);
    if (!Number.isFinite(end) || end < 1) throw new Error('Invalid issueEndNumber.');

    const lowerBound = Math.max(1, end - 100);
    const count = end - lowerBound + 1;

    // Base: uniform over the window
    const base = new Array(count).fill(1);

    // Build candidate numbers and keys
    const nums = Array.from({ length: count }, (_, i) => lowerBound + i);

    // Last seen memory (per issue number)
    const memKey = 'repo_rng_no_loop_v1';
    const mem = JSON.parse(localStorage.getItem(memKey) || '{}');
    const lastSeen = mem.lastSeen || {}; // { issueNumber: timestamp }
    const now = Date.now();

    // Cohort delta stats
    const deltas = nums
      .map(n => lastSeen[n])
      .filter(ts => typeof ts === 'number')
      .map(ts => now - ts);

    const meanDelta = deltas.length
      ? deltas.reduce((a,b)=>a+b,0) / deltas.length
      : null;

    // Deja multiplier (soft Gaussian around cohort mean gap; neutral if unknown)
    const dejaMults = nums.map(n => {
      const ts = lastSeen[n];
      if (typeof ts !== 'number' || meanDelta == null || meanDelta <= 0) return 1;
      const delta = now - ts;
      const sigma = meanDelta;                 // natural width from cohort
      const x = (delta - meanDelta) / (sigma || 1);
      const due = Math.exp(-(x*x));           // 0..1
      return 1 + due;                          // ∈ [1, 2]
    });

    // Dynamic beta via base entropy (strictly < 0.5 so base dominates)
    const baseSum = base.reduce((a,b)=>a+b, 0) || 1;
    const p = base.map(v => v / baseSum); // uniform here, but leave general
    let H = 0; for (let i=0;i<p.length;i++) if (p[i] > 0) H -= p[i]*Math.log(p[i]);
    const Hnorm = (p.length > 1) ? (H / Math.log(p.length)) : 0;

    let beta;
    {
      const g = dejaGate(now);
      const u = new Uint32Array(1); window.crypto.getRandomValues(u);
      const j = (u[0] / 0xffffffff);
      beta = 0.5 * g * (1 - Hnorm) * (0.75 + 0.25*j);
      if (beta >= 0.5) beta = 0.499;
      if (beta < 0) beta = 0;
    }

    // Optional tiny stochasticity on base before blend (keeps symmetry without bias)
    const std = 0.05;
    const baseNoisy = base.map(b => Math.max(1e-6, b + b * cryptoNormal(0, std)));

    // Blend: base*(1-beta) + base*beta*dejaMult; base dominates by construction
    let adjusted = baseNoisy.map((b, i) => Math.max(1e-9, b * ((1 - beta) + beta * (dejaMults[i] || 1))));

    // Normalize to probabilities
    const sum = adjusted.reduce((a,b)=>a+b, 0) || 1;
    const probs = adjusted.map(v => v / sum);

    // Sample index and compute chosen issue
    const idx = cryptoSampleIndex(probs);
    const randomChosenNumber = nums[idx];

    const user = finalRepo.username;
    const repo = finalRepo.repo;
    const chosenUrl = `https://github.com/${user}/${repo}/issues/${randomChosenNumber}`;

    // Persist lastSeen
    lastSeen[randomChosenNumber] = now;
    localStorage.setItem(memKey, JSON.stringify({ lastSeen }));

    // Redirect
    location.href = chosenUrl;

    // Fallback UI if redirect is blocked
    document.addEventListener('DOMContentLoaded', () => {
      const wrap = document.createElement('div');
      const h = document.createElement('h2');
      h.textContent = 'Redirecting to a random issue…';
      const pEl = document.createElement('p');
      pEl.innerHTML = `Selected range: <code>[${lowerBound}, ${end}]</code><br/>
                       Chosen issue: <code>#${randomChosenNumber}</code><br/>
                       Repository: <code>${user}/${repo}</code><br/>
                       Link: <a href="${chosenUrl}">${chosenUrl}</a>`;
      wrap.appendChild(h);
      wrap.appendChild(pEl);
      document.body.appendChild(wrap);
    });
  }

  main().catch(err => {
    document.body.textContent = err.message;
  });
})();
</script>

</body>
</html>
