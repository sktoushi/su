<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random Redirect (IndexedDB + Ratings)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Seed items: central source of truth (initial load only).
       After first run, weights are loaded/adjusted from IndexedDB. -->
  <script type="application/json" id="urlProbability">
  {
    "items": [
      { "probabilityWeight": 50,  "url": "https://sktoushi.github.io/su/skyway-scheduler1.html" }, 
      { "probabilityWeight": 25,  "url": "https://sktoushi.github.io/su/all503020.html" },
      { "probabilityWeight": 8,   "url": "https://sktoushi.github.io/su/ryspare-psei-202510.html" },
      { "probabilityWeight": 12,   "url": "https://sktoushi.github.io/su/allrecentbooks445.html" },
      { "probabilityWeight": 8,   "url": "https://sktoushi.github.io/su/berkshire-transcripts.html" },
      { "probabilityWeight": 5,   "url": "https://sktoushi.github.io/su/lc300.html?target=indexedDb-solomon-verses.csv" },
      { "probabilityWeight": 4,   "url": "https://sktoushi.github.io/su/canonical-stash3.html" }, 
      { "probabilityWeight": 15,  "url": "https://sktoushi.github.io/su/allrecent100books.html" },
      { "probabilityWeight": 7,   "url": "https://sktoushi.github.io/su/skyway-scheduler2-math.html" },
      { "probabilityWeight": 7,   "url": "https://sktoushi.github.io/su/skyway-scheduler2-mood.html" }
    ]
  }
  </script>

  <style>
    :root { --bg:#0b0c10; --fg:#cfd8dc; --muted:#90a4ae; --accent:#7cb342; --btn:#263238; --btn-hover:#37474f; --btn-active:#455a64; --danger:#e53935; }
    html, body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .hidden{display:none!important;}
    .wrap{display:grid; place-items:center; height:100vh; text-align:center; gap:1rem;}
    .small{color:var(--muted); font-size:.9rem;}
    .toolbar{display:inline-flex; gap:.5rem; align-items:center; flex-wrap:wrap; justify-content:center;}
    .btn{border:1px solid #111; background:var(--btn); color:var(--fg); padding:.6rem 1rem; border-radius:.5rem; font-size:1rem; cursor:pointer;
      transition: transform .05s ease, background .15s ease, box-shadow .15s ease; box-shadow:0 2px 0 rgba(0,0,0,.3); user-select:none;}
    .btn:hover{background:var(--btn-hover);}
    .btn:active{transform:translateY(1px); background:var(--btn-active);}
    .btn-accent{background:var(--accent); color:#0b0c10; border-color:#5a8e2f;}
    .btn-danger{background:var(--danger); color:#fff; border-color:#b71c1c;}
    .badge{font-size:.8rem; padding:.25rem .5rem; border-radius:.4rem; background:#1c313a; color:#b2dfdb;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
    dialog{border:none; border-radius:12px; padding:0; background:#11161a; color:var(--fg); width:min(560px,92vw);
      box-shadow:0 20px 60px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.05) inset;}
    dialog::backdrop{background:rgba(0,0,0,.6);}
    .modal{padding:1.25rem 1.25rem 1rem;}
    .modal h2{margin:0 0 .25rem 0; font-weight:700; font-size:1.2rem;}
    .modal p{margin:0 0 1rem 0; color:var(--muted);}
    .grid-5{display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); gap:.5rem;}
    .btn-mid{padding:.8rem .4rem; font-size:1.05rem; border-radius:.6rem;}
    .url-line{display:block; max-width:100%; white-space:normal; overflow-wrap:anywhere; word-break:break-word; text-overflow:clip;}
    .freqrow{display:flex; align-items:center; gap:.5rem;}
    .freqbadge{padding:.35rem .6rem; border:1px solid rgba(255,255,255,.08); border-radius:.5rem;
      background:#0f1519; color:#cfd8dc; font-variant-numeric:tabular-nums; min-width:7ch; text-align:center;}
    /* New for wildcard input */
    .field{display:flex; gap:.5rem; align-items:center; margin:.75rem 0 .25rem;}
    .input{flex:1; padding:.6rem .7rem; border-radius:.5rem; border:1px solid rgba(255,255,255,.08); background:#0f1519; color:#cfd8dc;}
    .help{font-size:.8rem; color:var(--muted); margin:.2rem 0 .8rem;}
    .error{color:#ff8a80; font-size:.85rem; margin-top:.25rem;}
  </style>

  <script>
    /************ Deterministic namespace + obfuscation helpers ************/
    function fnv1aHex(str) {
      let h = 0x811c9dc5 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193) >>> 0;
      }
      return ('00000000' + h.toString(16)).slice(-8);
    }
    const NS = fnv1aHex(location.origin + '|' + location.pathname);
    function obf(scope, name) {
      return `${scope}_${NS}_${fnv1aHex(scope + '|' + name + '|' + NS)}`;
    }

    /************ Constants (all obfuscated to avoid collisions) ************/
    const DB_NAME  = obf('db',   'scheduler1_v2');
    const DB_STORE = obf('st',   'urls_v2');
    const DB_VER   = 2; // meta-store already exists; no bump needed for new key

    const IDX_EFFECTIVE = obf('idx', 'effectiveWeight');
    const META_STORE = obf('meta', 'kvs');

    const KEY_FREQ_MINUTES = obf('k', 'freq_minutes');
    const KEY_LAST_SHOWN   = obf('k', 'last_shown_ms');
    /* NEW: Wildcard list key (array of URL strings) */
    const KEY_WILDCARD_LIST = obf('k', 'wildcards_v1');

    /* ▼▼ NEW: Visit tracking keys */
    const KEY_VISIT_COUNT        = obf('k', 'visit_count_v1');
    const KEY_SEGMENT_START_MS   = obf('k', 'segment_start_ms_v1'); // time at visit numbers 1,101,201,...
    const KEY_SEGMENT_100_MS     = obf('k', 'segment_100_ms_v1');   // time at visit numbers 100,200,300,...
    /* ▲▲ NEW */

    function lsKey(name) { return obf('ls', name); }
    const LS_WATCHDOG = lsKey('watchdog');

    const EDIT_URL = "https://github.com/sktoushi/su/edit/in/skyway-scheduler1.html";
    const RANDOM_PDF_MAX = 27;
    const SAFETY_FALLBACK_URL = "https://sktoushi.github.io/su/allrecent100.html";

    const RATING_PROBABILITY_ON_LOAD = 0.25; // informational
    const RATING_CHOICES = [-3, -1, 0, +1, +3];

    const FORCED_MIN_INTERVAL_MS = 15 * 60 * 1000;
    const DEFAULT_USER_INTERVAL_MS = 10 * 60 * 1000;
    const MODAL_SHOW_PROBABILITY = 0.15;
    const USER_MIN_FREQ_MINUTES = 5;
    const STEP_MINUTES = 5;

    /* ▼▼ NEW: delay before closing modal & redirecting after a user action (rate/skip) */
    const MODAL_ACTION_DELAY_MS = 30_000;
    /* ▲▲ NEW */

    /* ▼▼ NEW: Seed versioning / sync controls */
    const KEY_SEED_SIG = obf('k', 'seed_signature_v1');
    const SEED_SYNC_MODE = 'hard'; // 'hard' = reset deltas to match HTML; 'merge' = keep existing deltas
    /* ▲▲ NEW */

    /************ IndexedDB helpers (promise-wrapped) ************/
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            const store = db.createObjectStore(DB_STORE, { keyPath: 'url' });
            if (![...store.indexNames].includes(IDX_EFFECTIVE)) {
              store.createIndex(IDX_EFFECTIVE, 'effectiveWeight', { unique: false });
            }
          }
          if (!db.objectStoreNames.contains(META_STORE)) {
            db.createObjectStore(META_STORE); // simple KV: key -> value
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    function txStore(db, mode='readonly') {
      const tx = db.transaction(DB_STORE, mode);
      return [tx, tx.objectStore(DB_STORE)];
    }
    function getAll(db) {
      return new Promise((resolve, reject) => {
        const [tx, store] = txStore(db);
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }
    function getOne(db, key) {
      return new Promise((resolve, reject) => {
        const [tx, store] = txStore(db);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }
    function putMany(db, records) {
      return new Promise((resolve, reject) => {
        const [tx, store] = txStore(db, 'readwrite');
        records.forEach(rec => store.put(rec));
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => reject(tx.error);
      });
    }
    /* ===== Meta store helpers ===== */
    function metaGet(db, key) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(META_STORE, 'readonly');
        const st = tx.objectStore(META_STORE);
        const r = st.get(key);
        r.onsuccess = () => resolve(r.result);
        r.onerror = () => reject(r.error);
      });
    }
    function metaSet(db, key, value) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(META_STORE, 'readwrite');
        const st = tx.objectStore(META_STORE);
        const r = st.put(value, key);
        r.onsuccess = () => resolve(true);
        r.onerror = () => reject(r.error);
      });
    }

    /************ Utilities ************/
    function secureRandomFloat01() {
      const r = new Uint32Array(1);
      crypto.getRandomValues(r);
      return r[0] / 4294967296;
    }
    function chooseWeighted(items) {
      let total = 0;
      for (const it of items) {
        const base = Number(it.baseWeight || 0);
        const dlt  = Number(it.delta || 0);
        const w = Math.max(0, (isFinite(base)?base:0) + (isFinite(dlt)?dlt:0));
        it.effectiveWeight = w;
        total += w;
      }
      if (total <= 0) {
        total = items.reduce((s, it) => s + (Number(it.baseWeight || 0) || 0), 0) || 1;
        const threshold = Math.floor(secureRandomFloat01() * total);
        let acc = 0;
        for (const it of items) {
          acc += (Number(it.baseWeight || 0) || 0);
          if (threshold < acc) return it;
        }
        return items[0];
      }
      const threshold = Math.floor(secureRandomFloat01() * total);
      let acc = 0;
      for (const it of items) {
        acc += it.effectiveWeight;
        if (threshold < acc) return it;
      }
      return items[0];
    }
    function downloadJSON(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
    /* ▼▼ NEW: download plain text */
    function downloadText(filename, text) {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
    /* ▲▲ NEW */

    function fmtDateStamp() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`;
    }
    function safeParseSeed() {
      const raw = document.getElementById('urlProbability')?.textContent ?? '';
      try {
        return JSON.parse(raw);
      } catch (e) {
        const cleaned = raw
          .replace(/,\s*([\]}])/g, '$1')
          .replace(/\/\/.*$/gm, '');
        try {
          return JSON.parse(cleaned);
        } catch (e2) {
          console.error('Failed to parse seed JSON', e2);
          return { items: [] };
        }
      }
    }

    /* ▼▼ NEW: canonical string for seed to build a stable signature */
    function canonicalSeedString(seed) {
      const items = Array.isArray(seed?.items) ? seed.items.slice() : [];
      items.sort((a, b) => (a.url || '').localeCompare(b.url || ''));
      const canon = { items: items.map(it => ({
        url: String(it.url || ''),
        probabilityWeight: Number(it.probabilityWeight || 0)
      }))};
      return JSON.stringify(canon);
    }
    /* ▲▲ NEW */

    /************ Frequency helpers (use meta store) ************/
    const USER_MIN = USER_MIN_FREQ_MINUTES;
    function roundToStep(valueMinutes) {
      return Math.max(USER_MIN, Math.round(valueMinutes / STEP_MINUTES) * STEP_MINUTES);
    }
    async function getStoredFreqMinutes(db) {
      const val = await metaGet(db, KEY_FREQ_MINUTES);
      const n = Number(val);
      const mins = (!Number.isFinite(n) || n <= 0) ? (DEFAULT_USER_INTERVAL_MS / 60000) : n;
      return roundToStep(mins);
    }
    async function setStoredFreqMinutes(db, mins) {
      return metaSet(db, KEY_FREQ_MINUTES, roundToStep(mins));
    }
    async function getLastShownMs(db) {
      const v = await metaGet(db, KEY_LAST_SHOWN);
      const n = Number(v);
      return Number.isFinite(n) && n > 0 ? n : null;
    }
    async function markJustShown(db, nowMs = Date.now()) {
      return metaSet(db, KEY_LAST_SHOWN, Number(nowMs));
    }

    /************ Wildcard helpers (array of URLs in meta) ************/
    function isValidHttpUrl(str) {
      try {
        const u = new URL(str);
        return u.protocol === 'http:' || u.protocol === 'https:';
      } catch { return false; }
    }
    async function getWildcards(db) {
      const list = await metaGet(db, KEY_WILDCARD_LIST);
      return Array.isArray(list) ? list.filter(isValidHttpUrl) : [];
    }
    async function addWildcard(db, url) {
      if (!isValidHttpUrl(url)) return false;
      const curr = await getWildcards(db);
      if (!curr.includes(url)) {
        curr.push(url);
        await metaSet(db, KEY_WILDCARD_LIST, curr);
      }
      return true;
    }

    /************ Bootstrap DB from embedded JSON with redeploy sync ************/
    async function bootstrapDB(db) {
      const seed = safeParseSeed();
      const seedMap = new Map((seed.items || []).map(it => [it.url, Number(it.probabilityWeight || 0)]));

      // Compute a stable signature of the current seed (order-insensitive)
      const seedSig = fnv1aHex(canonicalSeedString(seed));
      const prevSig = await metaGet(db, KEY_SEED_SIG);

      const existing = await getAll(db);
      const existingMap = new Map(existing.map(r => [r.url, r]));

      const isRedeploy = prevSig && prevSig !== seedSig;
      const toPut = [];

      if (isRedeploy && SEED_SYNC_MODE === 'hard') {
        // HARD SYNC: reset seed URLs to exactly match HTML, preserve non-seed records
        for (const [url, baseWeight] of seedMap.entries()) {
          const rec = existingMap.get(url);
          const bw = Number(baseWeight) || 0;
          toPut.push({
            ...(rec || { url }),
            baseWeight: bw,
            delta: 0,
            effectiveWeight: Math.max(0, bw),
            lastRatedAt: rec?.lastRatedAt || 0
          });
          existingMap.delete(url);
        }
        // Keep any non-seed records intact
        for (const rec of existingMap.values()) {
          toPut.push(rec);
        }
      } else {
        // INITIAL BOOTSTRAP or SOFT MERGE: update baseWeight from HTML; keep delta for seed URLs
        for (const [url, baseWeight] of seedMap.entries()) {
          const rec = existingMap.get(url);
          if (rec) {
            const bw = Number(baseWeight) || 0;
            const dl = Number(rec.delta || 0);
            toPut.push({
              ...rec,
              baseWeight: bw,
              effectiveWeight: Math.max(0, bw + dl)
            });
            existingMap.delete(url);
          } else {
            const bw = Number(baseWeight) || 0;
            toPut.push({
              url,
              baseWeight: bw,
              delta: 0,
              effectiveWeight: bw,
              lastRatedAt: 0
            });
          }
        }
        // Keep any non-seed records intact
        for (const rec of existingMap.values()) {
          toPut.push(rec);
        }
      }

      await putMany(db, toPut);

      /* Ensure wildcard list key exists (initialize empty array exactly once) */
      const wild = await metaGet(db, KEY_WILDCARD_LIST);
      if (!Array.isArray(wild)) await metaSet(db, KEY_WILDCARD_LIST, []);

      // Persist the applied seed signature
      await metaSet(db, KEY_SEED_SIG, seedSig);

      return toPut;
    }

    /************ Rating modal (frequency controls + wildcard input + 30s auto-dismiss) ************/
    function showRatingModal(targetUrl, currentWeights, currentFreqMinutes, onPick, onSkip, onPersistFreq, onAddWildcard) {
      const dlg = document.getElementById('ratingDialog');
      const urlEl = document.getElementById('ratingUrl');
      const btnsWrap = document.getElementById('ratingButtons');
      const skipBtn = document.getElementById('skipRatingBtn');

      const freqDecBtn = document.getElementById('freqDec');
      const freqIncBtn = document.getElementById('freqInc');
      const freqValueEl = document.getElementById('freqValue');

      const wildInput = document.getElementById('wildUrlInput');
      const wildErr = document.getElementById('wildUrlError');

      let freqMinutes = currentFreqMinutes;
      let timeoutId = null;

      /* NEW: helper to wait 30s before proceeding on user actions */
      function delayProceed(fn) {
        setTimeout(fn, MODAL_ACTION_DELAY_MS);
      }

      function updateFreqUI() {
        if (freqValueEl) freqValueEl.textContent = `${freqMinutes} min`;
      }
      function clearTimer() {
        if (timeoutId !== null) { clearTimeout(timeoutId); timeoutId = null; }
      }
      function validateWildcard() {
        const val = (wildInput?.value || '').trim();
        if (!val) { if (wildErr) wildErr.textContent = ''; return { ok: true, value: '' }; }
        const ok = isValidHttpUrl(val);
        if (!ok && wildErr) wildErr.textContent = 'Please enter a valid http(s) URL.';
        if (ok && wildErr) wildErr.textContent = '';
        return { ok, value: val };
      }
      async function maybePersistWildcardThen(cb) {
        const { ok, value } = validateWildcard();
        if (!ok) return; // keep modal open; error text shown
        if (value) { try { await onAddWildcard?.(value); } catch {} }
        cb && cb();
      }
      function persistAndClose(cb) {
        try { onPersistFreq && onPersistFreq(freqMinutes); } catch {}
        try { dlg.close(); } catch { dlg.open = false; }
        cb && cb();
      }

      const base = Number(currentWeights?.baseWeight ?? 0) || 0;
      const delta = Number(currentWeights?.delta ?? 0) || 0;

      urlEl.textContent = targetUrl;
      btnsWrap.innerHTML = '';

      for (const val of RATING_CHOICES) {
        const b = document.createElement('button');
        b.className = 'btn btn-mid';
        b.textContent = (val > 0 ? `+${val}` : `${val}`);
        const projected = base + delta + val;
        if (projected <= 0) {
          b.disabled = true;
          b.title = 'Disabled: would reduce probability to zero or negative';
        }
        b.addEventListener('click', () => {
          if (b.disabled) return;
          clearTimer(); // cancel idle auto-dismiss now that user acted
          delayProceed(() => {
            maybePersistWildcardThen(() => persistAndClose(() => onPick(val)));
          });
        }, { once: true });
        btnsWrap.appendChild(b);
      }

      if (freqDecBtn) {
        freqDecBtn.onclick = () => { freqMinutes = Math.max(USER_MIN, freqMinutes - STEP_MINUTES); updateFreqUI(); };
      }
      if (freqIncBtn) {
        freqIncBtn.onclick = () => { freqMinutes = freqMinutes + STEP_MINUTES; updateFreqUI(); };
      }
      if (wildInput) {
        wildInput.addEventListener('input', validateWildcard);
        wildInput.addEventListener('blur', validateWildcard);
      }

      updateFreqUI();

      skipBtn.onclick = () => {
        clearTimer(); // cancel idle auto-dismiss; we'll handle timing
        delayProceed(() => {
          maybePersistWildcardThen(() => persistAndClose(onSkip));
        });
      };

      try { dlg.showModal(); } catch { dlg.show(); }

      /* Keep the existing auto-dismiss after 30s of inactivity */
      timeoutId = setTimeout(() => {
        maybePersistWildcardThen(() => persistAndClose(onSkip));
      }, 30_000);
    }

    /* ▼▼ NEW: duration formatter for receipts */
    function formatMeaningfulDuration(ms) {
      const mins = ms / 60000;
      if (mins < 60) {
        const m = Math.max(0, Math.round(mins));
        return `${m} minute${m === 1 ? '' : 's'}`;
      }
      const hours = ms / 3600000;
      if (hours < 24) {
        const h = Math.max(0, Math.round(hours));
        return `${h} hour${h === 1 ? '' : 's'}`;
      }
      const days = Math.floor(ms / 86400000);
      let remH = Math.round((ms % 86400000) / 3600000);
      if (remH === 24) { remH = 0; }
      const dPart = `${days} day${days === 1 ? '' : 's'}`;
      const hPart = `${remH} hour${remH === 1 ? '' : 's'}`;
      return `${dPart} ${hPart}`;
    }
    /* ▲▲ NEW */

    /* ▼▼ NEW: robust clipboard helper */
    async function copyTextToClipboard(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch {}
      // Fallback for older browsers or if permission denied
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        ta.setAttribute('readonly', '');
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch {
        return false;
      }
    }
    /* ▲▲ NEW */

    /************ Main flow ************/
    async function main() {
      const watchdog = setTimeout(() => {
        try { window.location.assign(SAFETY_FALLBACK_URL); } catch {}
      }, 5000);

      try {
        const db = await openDB();
        const records = await bootstrapDB(db);
        const wildcardList = await getWildcards(db); // << load once for this run

        /* ▼▼ NEW: Visit tracking logic */
        const now = Date.now();
        const rawCount = Number(await metaGet(db, KEY_VISIT_COUNT)) || 0;
        const newCount = rawCount + 1;

        // If this is 101st, 201st, 301st, ... attempt to generate receipt
        if ((newCount % 100) === 1 && newCount > 1) {
          const segStart = Number(await metaGet(db, KEY_SEGMENT_START_MS)); // time at (newCount-100)th visit
          const seg100   = Number(await metaGet(db, KEY_SEGMENT_100_MS));  // time at (newCount-1)th visit
          if (Number.isFinite(segStart) && Number.isFinite(seg100) && seg100 >= segStart) {
            const durMs = seg100 - segStart;
            const pretty = formatMeaningfulDuration(durMs);
            const rangeFrom = new Date(segStart).toISOString();
            const rangeTo   = new Date(seg100).toISOString();
            const windowStartVisit = newCount - 100;
            const windowEndVisit   = newCount - 1;
            const receipt =
`Page Visit Receipt
Window: visits ${windowStartVisit} to ${windowEndVisit}
From:   ${rangeFrom}
To:     ${rangeTo}
Duration: ${pretty}

Notes:
- Count increments once per page load.
- Duration measures time between the FIRST and the 100TH visit of the window.`;

            // 1) keep existing download
            downloadText(`visit-receipt-${fmtDateStamp()}.txt`, receipt);

            // 2) copy to clipboard (best effort)
            try { await copyTextToClipboard(receipt); } catch {}

            // 3) show as alert
            try { alert(`Visit receipt (copied to clipboard):\n\n${receipt}`); } catch {}
          }
        }

        // Mark special milestones for the rolling 100-visit windows:
        //  - at visit numbers 1,101,201,... store segment start time
        //  - at visit numbers 100,200,300,... store segment "100th" time
        if ((newCount % 100) === 1) {
          await metaSet(db, KEY_SEGMENT_START_MS, now);
        }
        if ((newCount % 100) === 0) {
          await metaSet(db, KEY_SEGMENT_100_MS, now);
        }
        await metaSet(db, KEY_VISIT_COUNT, newCount);
        /* ▲▲ NEW */

        document.getElementById('downloadBtn')?.addEventListener('click', async () => {
          const all = await getAll(db);
          const items = all.map(r => ({
            probabilityWeight: Math.max(0, Math.round((Number(r.baseWeight) || 0) + (Number(r.delta) || 0))),
            url: r.url
          }));
          downloadJSON(`items-updated-${fmtDateStamp()}.json`, { items });
        });

        // ===== Decide next URL first (no redirect yet) =====
        let nextUrl = null;
        const u = secureRandomFloat01();

        if (u < 0.02) {
          nextUrl = EDIT_URL;

        } else if (u < 0.12) {
          if (secureRandomFloat01() < 0.5) {
            nextUrl = `https://sktoushi.github.io/su/allrecent100.html`;
          } else {
            const chosenNumber = Math.floor(secureRandomFloat01() * RANDOM_PDF_MAX) + 1;
            nextUrl = `https://ryspare25.github.io/ref2510/viewer-pdfjs-4chan2.html?fileName=${chosenNumber}.pdf`;
          }

        /* NEW: 10% chance to pick from wildcard array if non-empty */
        } else if (wildcardList.length > 0 && secureRandomFloat01() < 0.10) {
          const idx = Math.floor(secureRandomFloat01() * wildcardList.length);
          nextUrl = wildcardList[idx];

        } else {
          const chosen = chooseWeighted(records.length ? records : (safeParseSeed().items || []).map(it => ({
            url: it.url, baseWeight: it.probabilityWeight, delta: 0
          })));
          nextUrl = chosen.url;
        }

        // ===== Modal timing decision (from meta store) =====
        const lastShown = await getLastShownMs(db);
        const elapsed = lastShown ? (now - lastShown) : Infinity;
        const currentFreqMinutes = await getStoredFreqMinutes(db);

        const mustShow = elapsed >= FORCED_MIN_INTERVAL_MS; // 15m guarantee
        const eligibleByUser = elapsed >= (currentFreqMinutes * 60 * 1000);
        const wantsSoftShow = eligibleByUser && (secureRandomFloat01() < MODAL_SHOW_PROBABILITY);
        const wantShow = mustShow || wantsSoftShow;

        const toRate = records.length
          ? records[Math.floor(secureRandomFloat01() * records.length)]
          : null;

        if (wantShow && toRate) {
          await markJustShown(db, now);

          showRatingModal(
            toRate.url,
            toRate,
            currentFreqMinutes,
            async (val) => {
              try {
                const rec = await getOne(db, toRate.url);
                const base = Number(rec?.baseWeight ?? toRate.baseWeight ?? 0) || 0;
                const newDelta = (Number(rec?.delta || 0) || 0) + Number(val || 0);
                const updated = {
                  ...(rec || { url: toRate.url }),
                  baseWeight: base,
                  delta: newDelta,
                  effectiveWeight: Math.max(0, base + newDelta),
                  lastRatedAt: Date.now()
                };
                await putMany(db, [updated]);
                const lastRatingNote = document.getElementById('lastRatingNote');
                if (lastRatingNote) {
                  lastRatingNote.textContent = `Last rating: ${val > 0 ? `+${val}` : val} for ${toRate.url}`;
                  lastRatingNote.classList.remove('hidden');
                }
              } finally {
                clearTimeout(watchdog);
                window.location.replace(nextUrl);
              }
            },
            () => {
              clearTimeout(watchdog);
              window.location.replace(nextUrl);
            },
            async (mins) => { await setStoredFreqMinutes(db, mins); },
            async (wildUrl) => { await addWildcard(db, wildUrl); } // persist wildcard if provided
          );
        } else {
          clearTimeout(watchdog);
          window.location.replace(nextUrl);
        }
      } catch (err) {
        console.error('Redirect flow failed:', err);
        window.location.assign(SAFETY_FALLBACK_URL);
      }
    }

    document.addEventListener('DOMContentLoaded', main);
  </script>
</head>
<body>
  <div class="wrap">
    <div><div class="badge">Random Redirect</div></div>
    <div class="small">Using <span class="mono">IndexedDB</span> to learn your weights over time.</div>
    <div class="toolbar">
      <button id="downloadBtn" class="btn btn-accent">Download updated <span class="mono">items</span> JSON</button>
      <span id="lastRatingNote" class="small hidden"></span>
    </div>
    <div class="small">You might be asked to rate a URL occasionally (-3, -1, 0, +1, +3).</div>
  </div>

  <!-- Rating modal -->
  <dialog id="ratingDialog">
    <div class="modal">
      <h2>How would you rate the probability weight for this URL?</h2>
      <p class="url-line mono" id="ratingUrl"></p>

      <!-- ▼ Modal frequency controls (±5m, floor 5m) -->
      <div class="small" style="margin:.5rem 0 .35rem;">Modal frequency</div>
      <div class="freqrow" style="margin-bottom:.35rem;">
        <button id="freqDec" type="button" class="btn btn-mid" aria-label="Decrease by 5 minutes">−5m</button>
        <span id="freqValue" class="freqbadge small">10 min</span>
        <button id="freqInc" type="button" class="btn btn-mid" aria-label="Increase by 5 minutes">+5m</button>
      </div>
      <div class="small" style="margin:.1rem 0 .9rem;">We’ll still show this at least once every 15 minutes.</div>
      <!-- ▲ End controls -->

      <!-- ▼ NEW: Wildcard URL entry -->
      <div class="small">Optional wildcard URL</div>
      <div class="field">
        <input id="wildUrlInput" class="input mono" type="url" placeholder="https://example.com/page" autocomplete="off" inputmode="url" />
      </div>
      <div id="wildUrlError" class="error"></div>
      <div class="help">If provided and valid, this URL is added to your wildcard pool (10% random pick when the pool isn’t empty).</div>
      <!-- ▲ End wildcard -->

      <div id="ratingButtons" class="grid-5" style="margin:.75rem 0 1rem;"></div>
      <div class="toolbar" style="justify-content:space-between; width:100%;">
        <button class="btn btn-danger" id="skipRatingBtn" title="Continue without rating">Skip</button>
        <span class="small">Choices: -3, -1, 0, +1, +3</span>
      </div>
    </div>
  </dialog>

  <noscript>
    <meta http-equiv="refresh" content="0;url=https://instagram.com/reels" />
    <style>body{font-family:sans-serif; padding:2rem;}</style>
    <p>If you’re seeing this, JavaScript is disabled. You’ll be sent to Instagram Reels in a moment.</p>
  </noscript>
</body>
</html>
