<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adaptive Weighted Redirect (Crypto RNG + Memory Drift)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; }
    code { background: #f2f2f2; padding: 0.1rem 0.3rem; border-radius: 4px; }
  </style>
  <script>
    (function () {
      // --- Crypto RNG helpers
      function cryptoRandom() {
        const buf = new Uint32Array(1);
        window.crypto.getRandomValues(buf);
        return buf[0] / 0xffffffff;
      }
      function cryptoNormal(mean = 0, stdDev = 1) {
        let u1 = 0, u2 = 0;
        while (u1 === 0) u1 = cryptoRandom();
        while (u2 === 0) u2 = cryptoRandom();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return z0 * stdDev + mean;
      }

      // --- Core configuration (add/remove URLs freely)
      const urls = [
        "https://sktoushi.github.io/su/skyway-scheduler1.html",        // base ~50%
        "https://sktoushi.github.io/su/all503020.html",                 // base ~25%
        "https://sktoushi.github.io/su/ryspare-psei-202510.html",       // base ~12.5%
        "https://sktoushi.github.io/su/berkshire-transcripts.html",      // base ~12.5%
        "https://sktoushi.github.io/su/lc300.html?target=indexedDb-solomon-verses.csv" 
        // Add more links here — picker will just work
      ];

      // If you provide weights, make sure they match urls.length.
      // If not, the script will fall back to equal weights automatically.
      const configuredBaseWeights = [0.5, 0.25, 0.1, 0.1, 0.05];

      // --- Helpers
      function normalizeWeights(arr) {
        const sum = arr.reduce((a, b) => a + b, 0);
        if (sum > 0 && isFinite(sum)) {
          return arr.map(w => w / sum);
        }
        // Fallback to uniform if sum is zero/invalid
        return Array(arr.length).fill(1 / arr.length);
      }

      function resizeCounts(storedCounts, targetLen) {
        const out = Array.isArray(storedCounts) ? storedCounts.slice(0, targetLen) : [];
        while (out.length < targetLen) out.push(0);
        return out;
      }

      // --- Load past stats
      const memoryKey = "redirect_memory_v2";
      const history = JSON.parse(localStorage.getItem(memoryKey) || "{}");
      let counts = resizeCounts(history.counts, urls.length);

      // --- Base weights (auto-fallback to uniform if mismatch)
      let baseWeights;
      if (Array.isArray(configuredBaseWeights) && configuredBaseWeights.length === urls.length) {
        baseWeights = normalizeWeights(configuredBaseWeights.slice());
      } else {
        baseWeights = Array(urls.length).fill(1 / urls.length);
      }

      // --- Compute adaptive bias (favor under-visited links)
      const totalVisits = counts.reduce((a, b) => a + b, 0);
      let bias = Array(urls.length).fill(0);
      if (totalVisits > 0) {
        const avg = totalVisits / counts.length;
        if (avg > 0) {
          bias = counts.map(c => ((avg - c) / avg) * 0.1); // up to ±10% adaptive bias
        }
      }

      // --- Determine noise volatility
      const erratic = cryptoRandom() < 0.1; // 10% chance for erratic mode
      const noiseStdDev = erratic ? 0.25 : 0.05;

      // --- Apply crypto noise and bias
      let noisyWeights = baseWeights.map((w, i) => {
        const noise = cryptoNormal(0, noiseStdDev) * w;
        const adaptive = bias[i] || 0;
        return Math.max(0, w + noise + adaptive);
      });

      // --- Normalize to sum = 1 (with safety fallback)
      noisyWeights = normalizeWeights(noisyWeights);

      // --- Choose target with crypto RNG (generic for N items)
      const r = cryptoRandom();
      let acc = 0;
      let chosenIndex = urls.length - 1; // default to last in case of rounding
      for (let i = 0; i < noisyWeights.length; i++) {
        acc += noisyWeights[i];
        if (r < acc) {
          chosenIndex = i;
          break;
        }
      }

      const target = urls[chosenIndex];

      // --- Update and persist memory
      counts[chosenIndex] += 1;
      localStorage.setItem(memoryKey, JSON.stringify({ counts }));

      // --- Redirect immediately
      window.location.replace(target);

      // --- Display diagnostic info if JS visible
      document.addEventListener("DOMContentLoaded", function () {
        const a = document.getElementById("target-link");
        if (a) a.href = target;
        const pre = document.getElementById("picked");
        if (pre) {
          const info =
            `weights: ${noisyWeights.map(w => (w * 100).toFixed(1) + "%").join(" / ")} | ` +
            (erratic ? "⚡ erratic mode" : "⤵ stable mode") +
            ` | visits: [${counts.join(", ")}]`;
          pre.textContent = target + " (" + info + ")";
        }
      });
    })();
  </script>
  <noscript>
    <meta http-equiv="refresh" content="0; url=https://sktoushi.github.io/su/all.html">
  </noscript>
</head>
<body>
  <h1>Redirecting…</h1>
  <p>If you’re not redirected automatically, <a id="target-link" href="https://sktoushi.github.io/su/all.html">click here</a>.</p>
  <p><small>Picked URL: <code id="picked">calculating…</code></small></p>
</body>
</html>
