<!doctype html>
<html lang="en" data-bs-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Droolish: Tiny Rules Engine (IndexedDB)</title>
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { padding-bottom: 5rem; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .h-8rem { height: 8rem; }
    .h-12rem { height: 12rem; }
    .cursor-pointer { cursor: pointer; }
    .table-fixed { table-layout: fixed; }
    .smallcaps { font-variant-caps: all-small-caps; }
    .sticky-footer { position: fixed; left: 0; right:0; bottom:0; }
    .wrap-anywhere { overflow-wrap:anywhere; }
    .badge-type { background: #eef; color:#223; border: 1px solid #ccd; }
    .badge-id { background:#efe; color:#232; border: 1px solid #cdc; }
    .shadow-soft { box-shadow: 0 0.25rem 0.75rem rgba(0,0,0,.06); }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg bg-body border-bottom sticky-top shadow-sm">
    <div class="container-fluid">
      <a class="navbar-brand fw-semibold" href="#">
        Droolish <span class="small text-muted">/ tiny rules engine</span>
      </a>
      <div class="d-flex gap-2">
        <button id="btnRun" class="btn btn-primary btn-sm">
          <span class="me-1">▶</span>Run Engine
        </button>
        <button id="btnStep" class="btn btn-outline-primary btn-sm">Step</button>
        <button id="btnExport" class="btn btn-outline-secondary btn-sm">Export State</button>
        <label class="btn btn-outline-secondary btn-sm mb-0">
          Import State <input id="importFile" type="file" accept="application/json" hidden />
        </label>
        <button id="btnReset" class="btn btn-outline-danger btn-sm">Reset DB</button>
      </div>
    </div>
  </nav>

  <!-- Config Alert -->
  <div id="configAlert" class="alert alert-info rounded-0 mb-0 d-none">
    <div class="container">
      <strong class="me-2">Config:</strong>
      <span id="cfgSummary" class="wrap-anywhere"></span>
    </div>
  </div>

  <main class="container my-4">

    <!-- Quick Stats -->
    <div class="row g-3 mb-2">
      <div class="col-12 col-lg-4">
        <div class="card shadow-soft">
          <div class="card-body">
            <div class="d-flex align-items-center justify-content-between">
              <div>
                <div class="small text-muted">Facts</div>
                <div id="factsCount" class="h3 mb-0">0</div>
              </div>
              <button id="btnNewFact" class="btn btn-success btn-sm">+ New Fact</button>
            </div>
          </div>
        </div>
      </div>
      <div class="col-12 col-lg-4">
        <div class="card shadow-soft">
          <div class="card-body">
            <div class="d-flex align-items-center justify-content-between">
              <div>
                <div class="small text-muted">Rules</div>
                <div id="rulesCount" class="h3 mb-0">0</div>
              </div>
              <button id="btnNewRule" class="btn btn-warning btn-sm">+ New Rule</button>
            </div>
          </div>
        </div>
      </div>
      <div class="col-12 col-lg-4">
        <div class="card shadow-soft">
          <div class="card-body">
            <div class="small text-muted">Engine</div>
            <div>
              <span class="badge text-bg-secondary">cycles: <span id="cycles">0</span></span>
              <span class="badge text-bg-secondary">max: <span id="maxCycles">—</span></span>
              <span class="badge text-bg-secondary">salience: <span id="salienceMode">desc</span></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Two Columns: Facts / Rules -->
    <div class="row g-4">
      <div class="col-12 col-lg-6">
        <div class="card shadow-soft">
          <div class="card-header d-flex align-items-center justify-content-between">
            <span class="fw-semibold">Facts</span>
            <div class="d-flex gap-2">
              <input id="factSearch" class="form-control form-control-sm" placeholder="Filter by type or content…" />
            </div>
          </div>
          <div class="card-body p-0">
            <div class="table-responsive">
              <table class="table table-sm align-middle mb-0 table-hover table-fixed">
                <thead class="table-light">
                  <tr>
                    <th style="width:6rem;">ID</th>
                    <th style="width:8rem;">Type</th>
                    <th>Data</th>
                    <th style="width:6rem;">Actions</th>
                  </tr>
                </thead>
                <tbody id="factsTbody"></tbody>
              </table>
            </div>
          </div>
          <div class="card-footer small text-muted">
            Each fact is <span class="mono">{ id, type, data }</span>. Use <em>type</em> to pattern-match in rules.
          </div>
        </div>
      </div>

      <div class="col-12 col-lg-6">
        <div class="card shadow-soft">
          <div class="card-header d-flex align-items-center justify-content-between">
            <span class="fw-semibold">Rules</span>
            <input id="ruleSearch" class="form-control form-control-sm" placeholder="Filter by name or pattern…" />
          </div>
          <div class="card-body p-0">
            <div class="table-responsive">
              <table class="table table-sm align-middle mb-0 table-hover">
                <thead class="table-light">
                  <tr>
                    <th>Name</th>
                    <th style="width:5rem;">Sal.</th>
                    <th>Patterns</th>
                    <th style="width:6rem;">Actions</th>
                  </tr>
                </thead>
                <tbody id="rulesTbody"></tbody>
              </table>
            </div>
          </div>
          <div class="card-footer small text-muted">
            Patterns are an array like:
            <span class="mono">[{ "var":"o", "type":"Order", "where":"o.data.total &gt; 100" }]</span>.
          </div>
        </div>
      </div>
    </div>

    <!-- Log -->
    <div class="card mt-4 shadow-soft">
      <div class="card-header d-flex align-items-center justify-content-between">
        <span class="fw-semibold">Log</span>
        <div class="d-flex gap-2">
          <button id="btnClearLog" class="btn btn-outline-secondary btn-sm">Clear</button>
          <button id="btnCopyLog" class="btn btn-outline-secondary btn-sm">Copy</button>
        </div>
      </div>
      <div class="card-body">
        <pre id="log" class="code h-12rem border rounded p-2 bg-body-tertiary mb-0"></pre>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="sticky-footer bg-body border-top">
    <div class="container py-2 small d-flex align-items-center justify-content-between">
      <div class="text-muted">IndexedDB: <span id="dbStatus">opening…</span></div>
      <div>
        <span class="text-muted me-2">Config file: <span id="configFileName">./config.json</span></span>
        <button id="btnReloadCfg" class="btn btn-sm btn-outline-secondary">Reload Config</button>
      </div>
    </div>
  </footer>

  <!-- Modals -->
  <div class="modal fade" id="factModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 id="factModalTitle" class="modal-title">New Fact</h5>
          <button class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <form id="factForm" class="vstack gap-3">
            <input type="hidden" id="factId">
            <div>
              <label class="form-label">Type</label>
              <input id="factType" class="form-control" placeholder="e.g., Order" required />
            </div>
            <div>
              <label class="form-label">Data (JSON)</label>
              <textarea id="factData" class="form-control code h-12rem" placeholder='{"total":120,"status":"new"}' required></textarea>
              <div class="form-text">Provide a valid JSON object.</div>
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button id="btnDeleteFact" class="btn btn-outline-danger me-auto d-none">Delete</button>
          <button class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button id="btnSaveFact" class="btn btn-primary">Save Fact</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="ruleModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 id="ruleModalTitle" class="modal-title">New Rule</h5>
          <button class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <form id="ruleForm" class="vstack gap-3">
            <input type="hidden" id="ruleId">
            <div>
              <label class="form-label">Name</label>
              <input id="ruleName" class="form-control" placeholder="e.g., Big orders get flagged" required />
            </div>
            <div>
              <label class="form-label">Salience (higher first)</label>
              <input id="ruleSalience" type="number" class="form-control" value="0" />
            </div>
            <div>
              <label class="form-label">Patterns (JSON Array)</label>
              <textarea id="rulePatterns" class="form-control code h-12rem" placeholder='[{"var":"o","type":"Order","where":"o.data.total > 100"}]' required></textarea>
              <div class="form-text">
                Each pattern binds a variable to a fact of a given <em>type</em>, then optional JS <em>where</em> expression filters it.
              </div>
            </div>
            <div>
              <label class="form-label">Action (JS)</label>
              <textarea id="ruleAction" class="form-control code h-12rem" placeholder="// Available: insert(type, data), modify(id, updater), retract(id), log(...), env, facts
// Example:
log('Flagging order', o.id);
modify(o.id, d => ({...d, flagged:true}));" required></textarea>
              <div class="form-text">
                Action runs with bindings for your pattern vars (e.g., <span class="mono">o</span>) and helpers listed above.
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button id="btnDeleteRule" class="btn btn-outline-danger me-auto d-none">Delete</button>
          <button class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button id="btnSaveRule" class="btn btn-warning">Save Rule</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="position-fixed top-0 end-0 p-3" style="z-index: 1080">
    <div id="toast" class="toast align-items-center text-bg-dark border-0" role="alert">
      <div class="d-flex">
        <div id="toastBody" class="toast-body small"></div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
      </div>
    </div>
  </div>

  <!-- Bootstrap + App -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
  ;(() => {
    // ---------- Config ----------
    const DEFAULT_CONFIG = {
      appName: "Droolish",
      maxCycles: 100,
      salience: "desc", // "desc" or "asc"
      allowEval: true,   // Allow evaluating rule 'where' and 'action' as JS
      logLevel: "info",  // "debug"|"info"|"warn"|"error"
      dbName: "droolish",
      dbVersion: 1
    };
    let CONFIG = { ...DEFAULT_CONFIG };
    const CONFIG_FILE = "./config.json"; // adjacent to index.html

    // ---------- IndexedDB ----------
    const DB = {
      db: null,
      open() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(CONFIG.dbName, CONFIG.dbVersion);
          req.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains("facts")) {
              const os = db.createObjectStore("facts", { keyPath: "id", autoIncrement: true });
              os.createIndex("by_type", "type", { unique: false });
            }
            if (!db.objectStoreNames.contains("rules")) {
              db.createObjectStore("rules", { keyPath: "id", autoIncrement: true });
            }
            if (!db.objectStoreNames.contains("meta")) {
              db.createObjectStore("meta", { keyPath: "key" });
            }
          };
          req.onsuccess = () => { DB.db = req.result; resolve(DB.db); };
          req.onerror = () => reject(req.error);
        });
      },
      tx(storeNames, mode = "readonly") {
        return DB.db.transaction(storeNames, mode);
      },
      async getAll(store) {
        return new Promise((resolve, reject) => {
          const req = DB.tx([store]).objectStore(store).getAll();
          req.onsuccess = () => resolve(req.result || []);
          req.onerror = () => reject(req.error);
        });
      },
      async get(store, key) {
        return new Promise((resolve, reject) => {
          const req = DB.tx([store]).objectStore(store).get(key);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      },
      async add(store, value) {
        return new Promise((resolve, reject) => {
          const req = DB.tx([store], "readwrite").objectStore(store).add(value);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      },
      async put(store, value) {
        return new Promise((resolve, reject) => {
          const req = DB.tx([store], "readwrite").objectStore(store).put(value);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      },
      async delete(store, key) {
        return new Promise((resolve, reject) => {
          const req = DB.tx([store], "readwrite").objectStore(store).delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      },
      async clearAll() {
        const tx = DB.tx(["facts", "rules", "meta"], "readwrite");
        await Promise.all([
          new Promise((res, rej) => { const r = tx.objectStore("facts").clear(); r.onsuccess = res; r.onerror = () => rej(r.error); }),
          new Promise((res, rej) => { const r = tx.objectStore("rules").clear(); r.onsuccess = res; r.onerror = () => rej(r.error); }),
          new Promise((res, rej) => { const r = tx.objectStore("meta").clear(); r.onsuccess = res; r.onerror = () => rej(r.error); }),
        ]);
        return true;
      }
    };

    // ---------- DOM Helpers ----------
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const toast = new bootstrap.Toast($("#toast"), { delay: 2500 });
    const showToast = (msg) => { $("#toastBody").textContent = msg; toast.show(); };
    const logEl = $("#log");
    const log = (...args) => {
      const line = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
      logEl.textContent += (line + "\n");
      logEl.scrollTop = logEl.scrollHeight;
      if (CONFIG.logLevel === "debug") console.debug("[Droolish]", ...args);
    };

    // ---------- UI Rendering ----------
    async function refreshFactsTable(filter = "") {
      const facts = await DB.getAll("facts");
      const tbody = $("#factsTbody");
      tbody.innerHTML = "";
      let shown = 0;
      for (const f of facts) {
        const rowStr = JSON.stringify(f).toLowerCase();
        if (filter && !rowStr.includes(filter.toLowerCase())) continue;
        shown++;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><span class="badge badge-id">${f.id}</span></td>
          <td><span class="badge badge-type">${escapeHtml(f.type)}</span></td>
          <td class="wrap-anywhere"><code class="small">${escapeHtml(JSON.stringify(f.data))}</code></td>
          <td>
            <div class="btn-group btn-group-sm">
              <button class="btn btn-outline-secondary btn-sm" data-action="edit" data-id="${f.id}">Edit</button>
              <button class="btn btn-outline-danger btn-sm" data-action="del" data-id="${f.id}">Del</button>
            </div>
          </td>
        `;
        tbody.appendChild(tr);
      }
      $("#factsCount").textContent = shown;
    }

    async function refreshRulesTable(filter = "") {
      const rules = await DB.getAll("rules");
      const tbody = $("#rulesTbody");
      tbody.innerHTML = "";
      let shown = 0;
      for (const r of rules) {
        const rowStr = JSON.stringify(r).toLowerCase();
        if (filter && !rowStr.includes(filter.toLowerCase())) continue;
        shown++;
        const pattPreview = escapeHtml(shorten(JSON.stringify(r.patterns || []), 120));
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="wrap-anywhere">${escapeHtml(r.name || "(unnamed)")}</td>
          <td class="text-end">${Number(r.salience||0)}</td>
          <td class="wrap-anywhere"><code class="small">${pattPreview}</code></td>
          <td>
            <div class="btn-group btn-group-sm">
              <button class="btn btn-outline-secondary btn-sm" data-action="edit" data-id="${r.id}">Edit</button>
              <button class="btn btn-outline-danger btn-sm" data-action="del" data-id="${r.id}">Del</button>
            </div>
          </td>
        `;
        tbody.appendChild(tr);
      }
      $("#rulesCount").textContent = shown;
    }

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }
    function shorten(s, n=100) {
      return s.length > n ? s.slice(0, n-1) + "…" : s;
    }

    // ---------- Modals (Facts) ----------
    const factModal = new bootstrap.Modal("#factModal");
    $("#btnNewFact").addEventListener("click", () => {
      $("#factModalTitle").textContent = "New Fact";
      $("#factId").value = "";
      $("#factType").value = "";
      $("#factData").value = "{}";
      $("#btnDeleteFact").classList.add("d-none");
      factModal.show();
    });
    $("#factsTbody").addEventListener("click", async (e) => {
      const btn = e.target.closest("button[data-action]");
      if (!btn) return;
      const id = Number(btn.dataset.id);
      const fact = await DB.get("facts", id);
      if (!fact) return;
      if (btn.dataset.action === "edit") {
        $("#factModalTitle").textContent = `Edit Fact #${id}`;
        $("#factId").value = id;
        $("#factType").value = fact.type;
        $("#factData").value = JSON.stringify(fact.data, null, 2);
        $("#btnDeleteFact").classList.remove("d-none");
        factModal.show();
      } else if (btn.dataset.action === "del") {
        await DB.delete("facts", id);
        showToast("Fact deleted.");
        refreshFactsTable($("#factSearch").value);
      }
    });
    $("#btnSaveFact").addEventListener("click", async () => {
      try {
        const id = $("#factId").value ? Number($("#factId").value) : null;
        const type = $("#factType").value.trim();
        const data = JSON.parse($("#factData").value || "{}");
        if (!type) return showToast("Type is required.");
        const record = id ? { id, type, data } : { type, data };
        await (id ? DB.put("facts", record) : DB.add("facts", record));
        showToast(id ? "Fact updated." : "Fact added.");
        factModal.hide();
        refreshFactsTable($("#factSearch").value);
      } catch (err) {
        console.error(err);
        showToast("Invalid JSON for fact data.");
      }
    });
    $("#btnDeleteFact").addEventListener("click", async () => {
      const id = Number($("#factId").value);
      if (!id) return;
      await DB.delete("facts", id);
      showToast("Fact deleted.");
      factModal.hide();
      refreshFactsTable($("#factSearch").value);
    });

    // ---------- Modals (Rules) ----------
    const ruleModal = new bootstrap.Modal("#ruleModal");
    $("#btnNewRule").addEventListener("click", () => {
      $("#ruleModalTitle").textContent = "New Rule";
      $("#ruleId").value = "";
      $("#ruleName").value = "";
      $("#ruleSalience").value = "0";
      $("#rulePatterns").value = '[{"var":"o","type":"Order","where":"o.data.total > 100"}]';
      $("#ruleAction").value =
`// Available: insert(type, data), modify(id, updater), retract(id), log(...), env, facts
log('Flagging order', o.id);
modify(o.id, d => ({...d, flagged:true}));`;
      $("#btnDeleteRule").classList.add("d-none");
      ruleModal.show();
    });
    $("#rulesTbody").addEventListener("click", async (e) => {
      const btn = e.target.closest("button[data-action]");
      if (!btn) return;
      const id = Number(btn.dataset.id);
      const rule = await DB.get("rules", id);
      if (!rule) return;
      if (btn.dataset.action === "edit") {
        $("#ruleModalTitle").textContent = `Edit Rule #${id}`;
        $("#ruleId").value = id;
        $("#ruleName").value = rule.name || "";
        $("#ruleSalience").value = Number(rule.salience || 0);
        $("#rulePatterns").value = JSON.stringify(rule.patterns || [], null, 2);
        $("#ruleAction").value = rule.action || "";
        $("#btnDeleteRule").classList.remove("d-none");
        ruleModal.show();
      } else if (btn.dataset.action === "del") {
        await DB.delete("rules", id);
        showToast("Rule deleted.");
        refreshRulesTable($("#ruleSearch").value);
      }
    });
    $("#btnSaveRule").addEventListener("click", async () => {
      try {
        const id = $("#ruleId").value ? Number($("#ruleId").value) : null;
        const name = $("#ruleName").value.trim();
        const salience = Number($("#ruleSalience").value || 0);
        const patterns = JSON.parse($("#rulePatterns").value || "[]");
        const action = $("#ruleAction").value || "";
        if (!Array.isArray(patterns)) return showToast("Patterns must be a JSON array.");
        const record = id ? { id, name, salience, patterns, action } : { name, salience, patterns, action };
        await (id ? DB.put("rules", record) : DB.add("rules", record));
        showToast(id ? "Rule updated." : "Rule added.");
        ruleModal.hide();
        refreshRulesTable($("#ruleSearch").value);
      } catch (err) {
        console.error(err);
        showToast("Invalid JSON in patterns, or other error.");
      }
    });
    $("#btnDeleteRule").addEventListener("click", async () => {
      const id = Number($("#ruleId").value);
      if (!id) return;
      await DB.delete("rules", id);
      showToast("Rule deleted.");
      ruleModal.hide();
      refreshRulesTable($("#ruleSearch").value);
    });

    // ---------- Filters ----------
    $("#factSearch").addEventListener("input", e => refreshFactsTable(e.target.value));
    $("#ruleSearch").addEventListener("input", e => refreshRulesTable(e.target.value));

    // ---------- Export / Import ----------
    $("#btnExport").addEventListener("click", async () => {
      const payload = {
        schema: 1,
        exportedAt: new Date().toISOString(),
        config: CONFIG,
        facts: await DB.getAll("facts"),
        rules: await DB.getAll("rules"),
        meta: await DB.getAll("meta"),
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `droolish-state-${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
      showToast("Exported current IndexedDB state.");
    });

    $("#importFile").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data || typeof data !== "object" || !Array.isArray(data.facts) || !Array.isArray(data.rules)) {
          showToast("Invalid import file.");
          return;
        }
        await DB.clearAll();
        for (const f of data.facts) await DB.add("facts", f);
        for (const r of data.rules) await DB.add("rules", r);
        if (Array.isArray(data.meta)) {
          for (const m of data.meta) await DB.add("meta", m);
        }
        showToast("Imported state into IndexedDB.");
        refreshFactsTable($("#factSearch").value);
        refreshRulesTable($("#ruleSearch").value);
      } catch (err) {
        console.error(err);
        showToast("Failed to import JSON.");
      } finally {
        e.target.value = "";
      }
    });

    // ---------- Reset ----------
    $("#btnReset").addEventListener("click", async () => {
      if (!confirm("This will clear facts, rules, and meta from IndexedDB. Continue?")) return;
      await DB.clearAll();
      showToast("Database cleared.");
      refreshFactsTable();
      refreshRulesTable();
    });

    // ---------- Engine ----------
    let CYCLES = 0;
    const setCycles = n => { CYCLES = n; $("#cycles").textContent = n; };

    // Compile a 'where' string to a function(bindings, env) => boolean
    function compileWhere(where) {
      if (!CONFIG.allowEval || !where || !where.trim()) return () => true;
      // where can reference bound variables by name (e.g., o, i)
      return new Function("bindings", "env", `
        with (bindings) { return !!(${where}); }
      `);
    }

    // Compile an 'action' body to function(bindings, helpers)
    function compileAction(action) {
      if (!CONFIG.allowEval || !action || !action.trim()) return () => {};
      return new Function("bindings", "helpers", `
        const { insert, modify, retract, log, env, facts } = helpers;
        with (bindings) {
          ${action}
        }
      `);
    }

    // Get facts by type for quick lookup
    function groupFactsByType(facts) {
      const map = new Map();
      for (const f of facts) {
        if (!map.has(f.type)) map.set(f.type, []);
        map.get(f.type).push(f);
      }
      return map;
    }

    // Cartesian product for pattern variables
    function* joinPatterns(patterns, factsByType) {
      // patterns: [{var, type, where}]
      const compiled = patterns.map(p => ({ ...p, whereFn: compileWhere(p.where||"") }));
      function* helper(i, acc) {
        if (i === compiled.length) { yield acc; return; }
        const p = compiled[i];
        const candidates = (factsByType.get(p.type) || []);
        for (const fact of candidates) {
          const bindings = { ...acc, [p.var]: fact };
          try {
            if (p.whereFn(bindings, { })) {
              yield* helper(i+1, bindings);
            }
          } catch (e) {
            log("where error:", e?.message||e);
          }
        }
      }
      yield* helper(0, {});
    }

    async function runOnce(env) {
      // Build agenda of activations then fire one based on salience
      const rules = await DB.getAll("rules");
      const facts = await DB.getAll("facts");
      const factsByType = groupFactsByType(facts);

      // Order rules by salience
      const ordered = [...rules].sort((a,b) => {
        const sa = Number(a.salience||0), sb = Number(b.salience||0);
        return CONFIG.salience === "asc" ? sa - sb : sb - sa;
      });

      const activations = [];
      for (const r of ordered) {
        if (!Array.isArray(r.patterns) || r.patterns.length === 0) continue;
        for (const bindings of joinPatterns(r.patterns, factsByType)) {
          activations.push({ rule: r, bindings });
        }
      }

      if (activations.length === 0) {
        log("No activations.");
        return false; // nothing fired
      }

      // Take first activation (FIFO within salience ordering)
      const { rule, bindings } = activations[0];
      const actionFn = compileAction(rule.action || "");
      log(`Firing rule: "${rule.name || "(unnamed)"}"`);
      // Helpers for action
      const helpers = {
        env,
        facts,
        log: (...a) => log(...a),
        insert: async (type, data) => {
          const id = await DB.add("facts", { type, data });
          log("insert:", type, "-> id", id);
        },
        modify: async (id, updater) => {
          const f = await DB.get("facts", Number(id));
          if (!f) { log("modify: fact not found", id); return; }
          let next = f.data;
          try {
            if (typeof updater === "function") {
              // We can't pass a real function from string, so support updater as a string body "d => ({...d, x:1})"
              next = updater(next);
            } else if (typeof updater === "string" && CONFIG.allowEval) {
              const up = new Function("d", `return (${updater})(d)`);
              next = up(next);
            } else if (typeof updater === "object") {
              next = { ...next, ...updater };
            }
          } catch (e) {
            log("modify error:", e?.message||e);
          }
          await DB.put("facts", { id: f.id, type: f.type, data: next });
          log("modify:", id);
        },
        retract: async (id) => {
          await DB.delete("facts", Number(id));
          log("retract:", id);
        }
      };

      try {
        await Promise.resolve(actionFn(bindings, helpers));
      } catch (e) {
        log("action error:", e?.message||e);
      }

      await refreshFactsTable($("#factSearch").value);
      return true;
    }

    async function runEngine(maxCycles) {
      let i = 0;
      const env = { now: Date.now() };
      for (; i < maxCycles; i++) {
        $("#cycles").textContent = i + 1;
        const progressed = await runOnce(env);
        if (!progressed) break;
      }
      setCycles(i);
      if (i >= maxCycles) {
        log(`Max cycles (${maxCycles}) reached.`);
      } else {
        log(`Engine stabilized after ${i} cycle(s).`);
      }
    }

    $("#btnRun").addEventListener("click", async () => {
      await runEngine(CONFIG.maxCycles);
    });
    $("#btnStep").addEventListener("click", async () => {
      await runOnce({ now: Date.now() });
      setCycles(CYCLES + 1);
    });

    // ---------- Log controls ----------
    $("#btnClearLog").addEventListener("click", () => { logEl.textContent = ""; });
    $("#btnCopyLog").addEventListener("click", async () => {
      await navigator.clipboard.writeText(logEl.textContent);
      showToast("Log copied to clipboard.");
    });

    // ---------- Config loader ----------
    async function loadConfig(show = true) {
      try {
        const res = await fetch(CONFIG_FILE, { cache: "no-store" });
        if (!res.ok) throw new Error("config not found");
        const cfg = await res.json();
        CONFIG = { ...DEFAULT_CONFIG, ...cfg };
        $("#cfgSummary").textContent = JSON.stringify(CONFIG);
        $("#configAlert").classList.toggle("d-none", !show);
        $("#salienceMode").textContent = CONFIG.salience;
        $("#maxCycles").textContent = CONFIG.maxCycles;
        document.title = CONFIG.appName || "Droolish";
      } catch (err) {
        // No config: keep defaults
        CONFIG = { ...DEFAULT_CONFIG };
        $("#cfgSummary").textContent = "(no config.json found; using defaults)";
        $("#configAlert").classList.toggle("d-none", !show);
        $("#salienceMode").textContent = CONFIG.salience;
        $("#maxCycles").textContent = CONFIG.maxCycles;
        document.title = CONFIG.appName || "Droolish";
      }
    }
    $("#btnReloadCfg").addEventListener("click", async () => {
      await loadConfig(true);
      showToast("Config reloaded.");
    });

    // ---------- Startup ----------
    (async function init() {
      await loadConfig(false);
      $("#dbStatus").textContent = "opening…";
      try {
        await DB.open();
        $("#dbStatus").textContent = `ready (${CONFIG.dbName})`;
      } catch (e) {
        $("#dbStatus").textContent = "error";
        showToast("Failed to open IndexedDB. Check browser settings.");
      }
      refreshFactsTable();
      refreshRulesTable();
      log("Welcome to Droolish. Create facts/rules, then Run Engine.");
      // Seed demo content if empty
      const [facts, rules] = await Promise.all([DB.getAll("facts"), DB.getAll("rules")]);
      if (facts.length === 0 && rules.length === 0) {
        await DB.add("facts", { type: "Order", data: { id:"A-1001", total: 150, status: "new" }});
        await DB.add("facts", { type: "Order", data: { id:"A-1002", total: 60, status: "new" }});
        await DB.add("rules", {
          name: "Flag big orders",
          salience: 10,
          patterns: [{ var:"o", type:"Order", where:"o.data.total > 100 && o.data.status==='new'"}],
          action:
`log('Flag big order', o.data.id);
modify(o.id, d => ({...d, flagged:true}));`
        });
        await refreshFactsTable();
        await refreshRulesTable();
        log("Seeded demo facts and rule.");
      }
    })();
  })();
  </script>
</body>
</html>
