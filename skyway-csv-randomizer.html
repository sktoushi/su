<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Weighted CSV Redirector (Headless)</title>
  <meta name="robots" content="noindex" />
  <style>
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;background:#0b1020;color:#dbe4ff;font:14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    .msg{opacity:.8;max-width:780px;padding:12px 16px;border:1px dashed #22325f;border-radius:12px;background:#0f1733}
    code{background:#0b1430;padding:1px 6px;border-radius:6px;border:1px solid #1e2e60}
  </style>
</head>
<body>
  <div class="msg" id="msg">Loading…</div>

  <script>
  (async function(){
    const Q = new URLSearchParams(location.search);
    // Accept the user's requested query param name: target=input.csv (falls back to input.csv)
    const FILENAME = (Q.get('target') || Q.get('file') || 'input.csv').replace(/^\/+/, '');

    const DB_NAME = 'csvCacheDB';
    const STORE = 'files';
    const VERSION = 1;
    const info = (t)=>{ const el=document.getElementById('msg'); if (el) el.textContent = t; console.log('[redirector]', t); };

    function openDB(){
      return new Promise((res,rej)=>{
        const req = indexedDB.open(DB_NAME, VERSION);
        req.onupgradeneeded = ()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); };
        req.onsuccess = ()=>res(req.result);
        req.onerror = ()=>rej(req.error);
      });
    }
    async function idbGet(id){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const r=st.get(id); r.onsuccess=()=>res(r.result||null); r.onerror=()=>rej(r.error); }); }
    async function idbSet(obj){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); const st=tx.objectStore(STORE); const r=st.put(obj); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); }); }

    function parseCSV(text){
      // simple CSV: supports quotes and commas; trims CRLF
      const rows=[]; let field='', cur=[], q=false; const s=text.replace(/\r/g,'');
      for(let i=0;i<s.length;i++){
        const ch=s[i];
        if(q){
          if(ch==='"'){
            if(s[i+1]==='"'){ field+='"'; i++; } else { q=false; }
          } else field+=ch;
        } else {
          if(ch==='"') q=true;
          else if(ch===','){ cur.push(field.trim()); field=''; }
          else if(ch==='\n'){ cur.push(field.trim()); rows.push(cur); cur=[]; field=''; }
          else field+=ch;
        }
      }
      if(field.length||cur.length){ cur.push(field.trim()); rows.push(cur); }
      return rows.filter(r=>r.some(x=>x&&x.length));
    }

    function normalizeRows(rows){
      if(!rows.length) return [];
      const firstLower = rows[0].map(x => (x||'').toLowerCase());

      // Header detection (robust): treat as header ONLY if we can see ALL 3 header keys among common aliases
      const alias = {
        type: new Set(['type','kind','category']),
        weight: new Set(['probabilityweight','probability','weight','w']),
        link: new Set(['link','url','href'])
      };
      const hasAllHeaders = (
        firstLower.some(x=>alias.type.has(x)) &&
        firstLower.some(x=>alias.weight.has(x)) &&
        firstLower.some(x=>alias.link.has(x))
      );

      let start = hasAllHeaders ? 1 : 0;
      let idx = { type: 0, weight: 1, link: 2 };

      if(hasAllHeaders){
        const map = {};
        firstLower.forEach((k,i)=>{
          if(alias.type.has(k)) map.type = i;
          if(alias.weight.has(k)) map.weight = i;
          if(alias.link.has(k)) map.link = i;
        });
        idx = { ...idx, ...map };
      }

      const out=[];
      for(let r=start; r<rows.length; r++){
        const row = rows[r];
        const type = row[idx.type] ?? '';
        const weight = Number(row[idx.weight] ?? '0');
        const link = row[idx.link] ?? '';
        if(!link) continue;
        if(!(weight>0)) continue;
        out.push({ type, probabilityWeight: weight, link });
      }
      return out;
    }

    function weightedPick(items){
      const total = items.reduce((s,it)=> s + (Number(it.probabilityWeight)||0), 0);
      if(!total) return null;
      let r = Math.random()*total, acc=0;
      for(const it of items){ acc += (Number(it.probabilityWeight)||0); if(r <= acc) return it; }
      return items[items.length-1]||null;
    }

    async function fetchCSVWithCache(name){
      const id = name;
      const cached = await idbGet(id);
      if(cached && cached.content){ info('Using cached CSV for '+name); return cached.content; }
      const url = './'+name;
      info('Fetching '+url);
      const res = await fetch(url, { cache: 'no-cache' });
      if(!res.ok) throw new Error('HTTP '+res.status+' '+res.statusText);
      const text = await res.text();
      await idbSet({ id, content:text, fetchedAt: Date.now() });
      info('Cached fresh copy');
      return text;
    }

    try{
      const text = await fetchCSVWithCache(FILENAME);
      const rows = parseCSV(text);
      const items = normalizeRows(rows);
      if(!items.length) throw new Error('No valid rows found (need type, positive probability, link).');
      const pick = weightedPick(items);
      if(!pick) throw new Error('Weighted pick failed.');

      // Use the link exactly as provided (no auto-prefixing)
      const href = String(pick.link).trim();
      if(!href){ throw new Error('Chosen row has empty link.'); }

      info('Redirecting…');
      location.replace(href);
    } catch(e){
      console.error(e);
      info('Error: '+(e && e.message || e));
    }
  })();
  </script>
</body>
</html>