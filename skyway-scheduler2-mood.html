<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta http-equiv="Cache-Control" content="no-store" />
<title>Mood Tracker (IndexedDB + SPC X-MR)</title>
<style>
  :root{
    --bg:#0b0c10; --fg:#cfd8dc; --muted:#90a4ae; --accent:#7cb342;
    --btn:#263238; --btn-hover:#37474f; --btn-active:#455a64; --danger:#e53935;
    --border:#1b2328; --paper:#11161a; --chip:#0f1519;
    --good:#64dd17; --warn:#ffb300; --bad:#ff5252;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    min-height:100svh}
  main{margin:2rem auto;width:min(100%,980px)}
  .paper{background:var(--paper);border-radius:18px;box-shadow:0 20px 60px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.05) inset;padding:1.25rem}
  h1{margin:.25rem 0 .35rem 0;font-weight:750;font-size:1.35rem}
  .lead{margin:.25rem 0 1rem 0;color:var(--muted)}
  .toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:flex-end}
  .btn{border:1px solid #111;background:var(--btn);color:var(--fg);padding:.6rem 1rem;border-radius:.5rem;font-size:1rem;cursor:pointer;
    transition:transform .05s ease,background .15s ease,box-shadow .15s ease;box-shadow:0 2px 0 rgba(0,0,0,.3);user-select:none;text-decoration:none}
  .btn:hover{background:var(--btn-hover)}
  .btn:active{transform:translateY(1px);background:var(--btn-active)}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn-accent{background:var(--accent);color:#0b0c10;border-color:#5a8e2f}
  .btn-danger{background:var(--danger);color:#fff;border-color:#b71c1c}
  .btn-outline{background:transparent;border-color:var(--border);color:var(--fg)}
  .btn-small{padding:.45rem .7rem;font-size:.95rem;border-radius:.45rem}
  .small{color:var(--muted);font-size:.92rem}
  .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
  .spacer{flex:1}
  .pill{font-size:.85rem;padding:.2rem .5rem;border-radius:.9rem;background:#1c313a;color:#b2dfdb;border:1px solid rgba(255,255,255,.06);letter-spacing:.2px}
  code{background:#0f1519;padding:0 .35rem;border-radius:.3rem;color:#d8e6df}
  .chips{display:flex;gap:.5rem;flex-wrap:wrap;margin:.5rem 0}
  .chip{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:.45rem .75rem;cursor:pointer}
  .chip:hover{background:#132028}
  .chip.active{outline:2px solid #7cb342}
  .list{margin-top:1rem;border-top:1px dashed rgba(255,255,255,.08)}
  .entry{display:grid;grid-template-columns:120px 1fr;gap:.75rem;padding:.6rem 0;border-bottom:1px dashed rgba(255,255,255,.08)}
  .score{font-weight:700}
  .tagline{color:var(--muted)}
  .badge{padding:.1rem .4rem;border-radius:.4rem;border:1px solid var(--border);font-size:.8rem}
  .badge.bad{border-color:#7f1d1d;color:#ffb4af;background:rgba(229,57,53,.12)}
  .badge.warn{border-color:#5f370e;color:#ffd8a8;background:rgba(255,179,0,.12)}
  .badge.good{border-color:#1b5e20;color:#b9f6ca;background:rgba(100,221,23,.12)}

  /* Modal */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;place-items:center;padding:1rem}
  /* FIX: show the backdrop when 'show' is toggled */
  .modal-backdrop.show{display:grid;}
  .modal{width:min(100%,560px);background:var(--paper);border-radius:14px;border:1px solid var(--border);box-shadow:0 30px 70px rgba(0,0,0,.6);padding:1rem}
  .modal header{display:flex;align-items:center;justify-content:space-between}
  /* (this rule is harmless if kept; the inner .modal never gets 'show') */
  .modal.show{display:grid}
  .field{margin:.75rem 0}
  .field label{display:block;margin-bottom:.35rem;font-weight:600}
  .field input[type="range"]{width:100%}
  .field input[type="text"], .field textarea{
    width:100%;background:#0c1114;border:1px solid var(--border);border-radius:.5rem;color:var(--fg);
    padding:.65rem .75rem;font:inherit
  }

  /* SPC area */
  .grid{display:grid;grid-template-columns:1fr;gap:1rem}
  @media (min-width:900px){ .grid{grid-template-columns:1.1fr .9fr} }
  .card{background:#0c1114;border:1px solid var(--border);border-radius:12px;padding:1rem}
  .kv{display:grid;grid-template-columns:1fr 1fr;gap:.4rem .75rem}
  .kv div{padding:.15rem 0;border-bottom:1px dashed rgba(255,255,255,.06)}
  .kv b{font-weight:700}
  canvas{width:100%;height:260px;background:white;border-radius:8px;display:block}

  /* Focus */
  .btn:focus-visible, a:focus-visible, input:focus-visible, textarea:focus-visible, .chip:focus-visible{
    outline:2px solid #9ccc65;outline-offset:2px
  }
</style>
</head>
<body>
  <main>
    <section class="paper" aria-labelledby="title">
      <header class="row" style="justify-content:space-between">
        <div>
          <h1 id="title">Mood Tracker (IndexedDB + SPC)</h1>
          <p class="lead small">Log your mood (1‚Äì10) with an optional cause. We compute an X-MR control chart and flag signals.</p>
        </div>
        <div class="toolbar">
          <button id="addBtn" class="btn btn-accent btn-small">‚ûï Add entry</button>
          <button id="clearBtn" class="btn btn-outline btn-small" title="Clear all data">üóëÔ∏è Clear all</button>
        </div>
      </header>

      <div class="row small" style="margin:.35rem 0 1rem 0">
        <span class="pill" id="status" aria-live="polite">Ready</span>
        <span class="pill" id="countPill">Entries: 0</span>
      </div>

      <div class="grid">
        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">Your entries</h3>
          <div class="chips" id="tagChips" aria-label="Previous tags"></div>
          <div id="entries" class="list" aria-live="polite"></div>
        </div>

        <div class="card">
          <h3 style="margin:.25rem 0 .5rem 0">SPC (Individuals & Moving Range)</h3>
          <div class="kv small" id="spcMeta"></div>
          <div style="margin:.6rem 0">
            <canvas id="xChart" aria-label="Individuals chart" tabindex="0"></canvas>
          </div>
          <div style="margin:.6rem 0">
            <canvas id="mrChart" aria-label="Moving range chart" tabindex="0"></canvas>
          </div>
          <details open>
            <summary><b>Signals & notes</b></summary>
            <ul id="signals" class="small" style="line-height:1.45"></ul>
          </details>
          <div class="row" style="margin-top:.6rem">
            <div class="spacer"></div>
            <button id="copyExplain" class="btn btn-accent btn-small">üìã Copy SPC + open ChatGPT</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Modal -->
  <div id="modalWrap" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="mTitle" aria-hidden="true">
    <div class="modal">
      <header>
        <h2 id="mTitle" style="margin:.2rem 0">Add mood entry</h2>
        <button id="closeModal" class="btn btn-outline btn-small" aria-label="Close">‚úï</button>
      </header>
      <div class="field">
        <label for="moodRange">Mood score: <b><span id="moodVal">5</span>/10</b></label>
        <input id="moodRange" type="range" min="1" max="10" step="1" value="5" />
      </div>
      <div class="field">
        <label for="tagInput">Optional text (concern / cause)</label>
        <input id="tagInput" type="text" placeholder="e.g., poor sleep, work stress, gym, friends, caffeine, rain" />
        <div id="recentChips" class="chips" aria-label="Quick pick from previous"></div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:.5rem">
        <button id="saveEntry" class="btn btn-accent">üíæ Save</button>
      </div>
    </div>
  </div>

<script>
/* ===== Utilities ===== */
const $ = s => document.querySelector(s);
const statusEl = $("#status"); const entriesEl = $("#entries"); const tagChipsEl = $("#tagChips");
const countPill = $("#countPill");
const modalWrap = $("#modalWrap"); const closeModalBtn = $("#closeModal");
const moodRange = $("#moodRange"); const moodVal = $("#moodVal");
const tagInput = $("#tagInput"); const recentChips = $("#recentChips");
const xChart = $("#xChart"); const mrChart = $("#mrChart");
const copyExplainBtn = $("#copyExplain");

function setStatus(msg, kind="info"){
  statusEl.textContent = msg;
  if(kind==="ok"){ statusEl.style.background="#1c313a"; statusEl.style.color="#b2dfdb"; }
  else if(kind==="err"){ statusEl.style.background="rgba(229,57,53,.15)"; statusEl.style.color="#ffb4af"; }
  else { statusEl.style.background="#1c313a"; statusEl.style.color="#b2dfdb"; }
}

function uuid(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  // Fallback RFC4122-ish
  const bytes = new Uint8Array(16);
  (crypto?.getRandomValues ? crypto.getRandomValues(bytes) : bytes.fill(Math.floor(Math.random()*256)));
  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const h = [...bytes].map(b=>b.toString(16).padStart(2,"0")).join("");
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
}

/* ===== IndexedDB ===== */
const DB_NAME = "moodDB_v1";
const STORE = "moods";
let dbPromise;
function openDB(){
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME,1);
    req.onupgradeneeded = () => {
      const db = req.result;
      const store = db.createObjectStore(STORE, { keyPath:"id" });
      store.createIndex("by_time","time",{unique:false});
      store.createIndex("by_tag","tag",{unique:false});
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return dbPromise;
}

async function addEntry(score, tagText){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readwrite");
    const store = tx.objectStore(STORE);
    const item = { id: uuid(), time: Date.now(), score, tag: (tagText||"").trim() };
    store.add(item);
    tx.oncomplete = () => resolve(item);
    tx.onerror = () => reject(tx.error);
  });
}

async function getAllEntries(){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readonly");
    const store = tx.objectStore(STORE);
    const req = store.getAll();
    req.onsuccess = () => resolve(req.result.sort((a,b)=>a.time-b.time));
    req.onerror = () => reject(req.error);
  });
}

async function clearAll(){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,"readwrite");
    tx.objectStore(STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

/* ===== Modal ===== */
function openModal(){
  modalWrap.classList.add("show");
  modalWrap.setAttribute("aria-hidden","false");
  tagInput.value = "";
  moodRange.value = "5"; moodVal.textContent = "5";
  buildRecentChips();
  setTimeout(()=>tagInput.focus(), 10);
}
function closeModal(){
  modalWrap.classList.remove("show");
  modalWrap.setAttribute("aria-hidden","true");
}
$("#addBtn").addEventListener("click", openModal);
$("#closeModal").addEventListener("click", closeModal);
modalWrap.addEventListener("click", e=>{ if(e.target===modalWrap) closeModal(); });
moodRange.addEventListener("input", ()=>{ moodVal.textContent = moodRange.value; });
// Convenience: close on Escape
document.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && modalWrap.classList.contains("show")) closeModal(); });

/* ===== Chip helpers ===== */
function makeChip(text, onClick){
  const chip = document.createElement("button");
  chip.type = "button";
  chip.className = "chip btn-small";
  chip.textContent = text;
  chip.addEventListener("click", (e) => onClick(e)); // pass event explicitly
  return chip;
}

function buildTagBar(all){
  // Top bar showing distinct tags: most recent 12 non-empty, dedup
  const seen = new Set(); const list = [];
  [...all].reverse().forEach(e => {
    const t = (e.tag||"").trim();
    if(t && !seen.has(t)){ seen.add(t); list.push(t); }
  });
  tagChipsEl.innerHTML="";
  list.slice(0,12).forEach(t=>{
    tagChipsEl.appendChild(makeChip(t, (e)=>{
      // filter view by tag (toggle)
      const active = e.currentTarget.classList.toggle("active");
      document.querySelectorAll(".chip").forEach(c=>{
        if(c!==e.currentTarget && c.parentElement===tagChipsEl) c.classList.remove("active");
      });
      renderEntries(active ? all.filter(e2=> (e2.tag||"").trim()===t) : all);
    }));
  });
  // Also add quick "All" chip
  tagChipsEl.prepend(makeChip("All", (e)=>{ 
    document.querySelectorAll(".chip").forEach(c=>c.classList.remove("active"));
    renderEntries(all);
  }));
}

async function buildRecentChips(){
  const all = await getAllEntries();
  const seen = new Set(); const list = [];
  [...all].reverse().forEach(e=>{
    const t = (e.tag||"").trim();
    if(t && !seen.has(t)){ seen.add(t); list.push(t); }
  });
  recentChips.innerHTML="";
  list.slice(0,10).forEach(t=>{
    recentChips.appendChild(makeChip(t, ()=>{
      tagInput.value = t;
    }));
  });
  if(list.length===0){
    recentChips.innerHTML = `<span class="small" style="opacity:.8">No previous causes yet. Add one!</span>`;
  }
}

/* ===== Rendering entries ===== */
function fmtDate(ts){
  const d = new Date(ts);
  return d.toLocaleString(undefined,{year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'});
}
function renderEntries(all){
  countPill.textContent = `Entries: ${all.length}`;
  entriesEl.innerHTML = "";
  if(all.length===0){
    entriesEl.innerHTML = `<div class="small" style="padding:1rem 0;opacity:.8">No entries yet. Click <b>‚ûï Add entry</b> to start.</div>`;
    renderSPC([]); return;
  }
  all.forEach(e=>{
    const div = document.createElement("div");
    div.className = "entry";
    const quality = e.score>=8 ? "good" : e.score<=3 ? "bad" : "warn";
    div.innerHTML = `
      <div>
        <div class="score">Mood: ${e.score}/10</div>
        <div class="tagline small">${fmtDate(e.time)}</div>
      </div>
      <div>
        ${(e.tag? `<span class="badge ${quality}">${e.tag}</span>`:"")}
      </div>
    `;
    entriesEl.appendChild(div);
  });
  renderSPC(all);
}

/* ===== SPC (X-MR) =====
   Using Individuals (X) and Moving Range (MR) with constants:
   For MR of size 2: d2 = 1.128, E2-like via sigma = MRbar/d2, so UCL/LCL = mean ¬± 3*sigma.
   MR UCL = 3.267 * MRbar (n=2), LCL_MR = 0 by convention.
*/
function spcCompute(values){
  const n = values.length;
  if(n===0) return { n:0 };
  const mean = values.reduce((a,b)=>a+b,0)/n;
  const mrs = [];
  for(let i=1;i<n;i++) mrs.push(Math.abs(values[i]-values[i-1]));
  const mrbar = mrs.length? mrs.reduce((a,b)=>a+b,0)/mrs.length : 0;
  const d2 = 1.128;
  const sigma = mrbar/d2;
  const ucl = mean + 3*sigma;
  const lcl = mean - 3*sigma;
  const mrUCL = 3.267*mrbar;
  const mrLCL = 0;

  // Rule checks
  const signals = [];
  // 1) Any point beyond control limits
  values.forEach((x,i)=>{
    if(x>ucl || x<lcl) signals.push({i, rule:"Point beyond 3œÉ limit", value:x});
  });
  // 2) 8 in a row on one side of mean
  (function(){
    let runStart=0, prevSide = Math.sign(values[0]-mean);
    for(let i=1;i<n;i++){
      const side = Math.sign(values[i]-mean);
      if(side===0){ runStart=i; prevSide=0; continue; }
      if(side===prevSide && side!==0) {
        if(i-runStart+1>=8) signals.push({i, rule:"‚â•8 in a row on one side of mean", value:values[i]});
      } else { runStart=i; }
      prevSide = side;
    }
  })();
  // 3) 6 points trending up or down
  (function(){
    let up=1, dn=1;
    for(let i=1;i<n;i++){
      if(values[i]>values[i-1]){ up++; dn=1; }
      else if(values[i]<values[i-1]){ dn++; up=1; }
      else { up=1; dn=1; }
      if(up>=6) signals.push({i, rule:"‚â•6 increasing", value:values[i]});
      if(dn>=6) signals.push({i, rule:"‚â•6 decreasing", value:values[i]});
    }
  })();
  // 4) MR beyond MR UCL
  mrs.forEach((r,i)=>{ if(r>mrUCL) signals.push({i:i+1, rule:"Moving range beyond MR UCL", value:r}); });

  return { n, mean, mrbar, sigma, ucl, lcl, mrUCL, mrLCL, mrs, signals };
}

function drawChart(canvas, xs, meta, opts){
  const ctx = canvas.getContext("2d");
  const W = canvas.width = canvas.clientWidth * devicePixelRatio;
  const H = canvas.height = canvas.clientHeight * devicePixelRatio;
  const pad = 30*devicePixelRatio;
  const x0 = pad, y0 = H - pad, x1 = W - pad, y1 = pad;

  // Compute bounds
  const min = Math.min(...xs, opts.minOverride ?? Infinity);
  const max = Math.max(...xs, opts.maxOverride ?? -Infinity);
  const rng = (max-min) || 1;

  // Helpers
  const xAt = i => x0 + (i/(xs.length-1 || 1))*(x1-x0);
  const yAt = v => y0 - ((v - min)/rng)*(y0 - y1);

  // Clear
  ctx.clearRect(0,0,W,H);
  ctx.scale(1,1);
  ctx.lineWidth = 2*devicePixelRatio;

  // Axes
  ctx.strokeStyle = "#e0e0e0"; ctx.globalAlpha=.6;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.stroke();
  ctx.globalAlpha=1;

  // Limits/mean lines
  function hline(val, color, dash=[]){
    ctx.save(); ctx.setLineDash(dash); ctx.strokeStyle=color; ctx.beginPath();
    ctx.moveTo(x0, yAt(val)); ctx.lineTo(x1, yAt(val)); ctx.stroke(); ctx.restore();
  }
  if(opts.mean!==undefined) hline(opts.mean, "#1976d2", [8,6]);
  if(opts.ucl!==undefined)  hline(opts.ucl,  "#d32f2f", [6,6]);
  if(opts.lcl!==undefined)  hline(opts.lcl,  "#d32f2f", [6,6]);

  // Line
  ctx.strokeStyle = "#000"; // default black for visibility on white canvas
  ctx.beginPath();
  xs.forEach((v,i)=>{ const x=xAt(i), y=yAt(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();

  // Points
  xs.forEach((v,i)=>{
    const x=xAt(i), y=yAt(v);
    const out = (opts.ucl!==undefined && (v>opts.ucl||v<opts.lcl));
    ctx.fillStyle = out ? "#d32f2f" : "#000";
    ctx.beginPath(); ctx.arc(x,y,4*devicePixelRatio,0,Math.PI*2); ctx.fill();
  });
}

function renderSPC(all){
  const spcMeta = $("#spcMeta");
  const signalsEl = $("#signals");
  const scores = all.map(e=>Number(e.score));
  if(scores.length===0){
    spcMeta.innerHTML = `<div>No data</div>`;
    signalsEl.innerHTML = "";
    // Clear charts
    drawChart(xChart, [0], {}, {minOverride:0,maxOverride:10});
    drawChart(mrChart, [0], {}, {minOverride:0,maxOverride:5});
    return;
  }
  const M = spcCompute(scores);

  // Meta grid key/values
  const kv = [
    ["Count (n)", M.n],
    ["Mean (XÃÑ)", M.mean.toFixed(3)],
    ["MRÃÑ", M.mrbar.toFixed(3)],
    ["œÉ (estimated)", M.sigma.toFixed(3)],
    ["UCL (X)", M.ucl.toFixed(3)],
    ["LCL (X)", M.lcl.toFixed(3)],
    ["UCL (MR)", M.mrUCL.toFixed(3)],
    ["LCL (MR)", M.mrLCL.toFixed(3)]
  ];
  spcMeta.innerHTML = kv.map(([k,v])=>`<div><b>${k}</b></div><div>${v}</div>`).join("");

  // Signals
  if(M.signals.length===0){
    signalsEl.innerHTML = `<li>No rule violations detected. Process appears in control.</li>`;
  }else{
    signalsEl.innerHTML = M.signals.map(s=>{
      const idx = s.i+1;
      const tag = (all[idx-1]?.tag||"").trim();
      const hint = tag ? ` ‚Äî hint: ‚Äú${tag}‚Äù` : "";
      return `<li>Point #${idx}: ${s.rule} (value=${("value" in s? s.value.toFixed?.(3) ?? s.value : "")})${hint}</li>`;
    }).join("");
  }

  // Charts
  drawChart(xChart, scores, M, {mean:M.mean, ucl:M.ucl, lcl:M.lcl, minOverride:Math.min(0, ...scores), maxOverride:Math.max(10, ...scores)});
  const mrs = M.mrs.length? M.mrs : [0];
  drawChart(mrChart, mrs, M, {mean:M.mrbar, ucl:M.mrUCL, lcl:M.mrLCL, minOverride:0, maxOverride:Math.max(1, ...mrs)});

  // Prepare "explain" payload
  copyExplainBtn.onclick = async ()=>{
    const lines = [];
    lines.push(`Dataset size n=${M.n}`);
    lines.push(`Mean (XÃÑ)=${M.mean.toFixed(3)}, MRÃÑ=${M.mrbar.toFixed(3)}, œÉ‚âà${M.sigma.toFixed(3)}`);
    lines.push(`Control limits (X): LCL=${M.lcl.toFixed(3)}, UCL=${M.ucl.toFixed(3)}`);
    lines.push(`Control limits (MR): LCL=${M.mrLCL.toFixed(3)}, UCL=${M.mrUCL.toFixed(3)}`);
    lines.push(`Values: [${scores.join(", ")}]`);
    const tags = all.map(e=> (e.tag||"").trim() ? `"${e.tag.trim()}"` : '""');
    lines.push(`Tags (aligned): [${tags.join(", ")}]`);
    if(M.signals.length===0) lines.push("Signals: none.");
    else lines.push("Signals:", ...M.signals.map(s=>{
      const idx = s.i+1;
      const tag = (all[idx-1]?.tag||"").trim();
      const hint = tag ? ` (hint: ${tag})` : "";
      return `#${idx} ‚Äî ${s.rule}${hint}`;
    }));

    const payload = `4chan: explain this\nMood tracker SPC summary:\n${lines.join("\n")}`;
    try{
      await navigator.clipboard.writeText(payload);
      window.open(`https://chat.openai.com/?q=${encodeURIComponent(payload)}`,"_blank","noopener");
      const old = copyExplainBtn.innerHTML;
      copyExplainBtn.classList.remove("btn-accent"); copyExplainBtn.classList.add("btn-outline");
      copyExplainBtn.innerHTML = "‚úÖ Copied & launched!";
      setTimeout(()=>{ copyExplainBtn.classList.remove("btn-outline"); copyExplainBtn.classList.add("btn-accent"); copyExplainBtn.innerHTML=old; }, 1600);
    }catch(e){
      console.error(e);
      setStatus("Copy or open failed.", "err");
    }
  };
}

/* ===== Save flow ===== */
$("#saveEntry").addEventListener("click", async ()=>{
  const score = Number(moodRange.value);
  const tag = tagInput.value;
  try{
    const item = await addEntry(score, tag);
    setStatus("Saved.", "ok");
    closeModal();
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(e){
    console.error(e); setStatus("Save failed", "err");
  }
});

$("#clearBtn").addEventListener("click", async ()=>{
  if(!confirm("Clear ALL mood entries? This cannot be undone.")) return;
  await clearAll();
  setStatus("All entries cleared.", "ok");
  const all = await getAllEntries();
  buildTagBar(all);
  renderEntries(all);
});

/* ===== Boot ===== */
(async ()=>{
  try{
    await openDB();
    const all = await getAllEntries();
    buildTagBar(all);
    renderEntries(all);
  }catch(e){
    console.error(e); setStatus("Initialization failed", "err");
  }
})();
</script>
</body>
</html>
